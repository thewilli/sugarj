package test.compilermods;
import org.sugarj.languages.Dryad;
import org.sugarj.languages.SugarDryad;
sugar mods{
	
	signature constructors
		HDI : Nothing
		HDF : Nothing

	signature constructors
		MethodName : A * B * C * D -> E
		CompileTimeDeclaration : A -> B
		DeclaringClass : A -> B
		Assign : A -> B
	
	strategies

		hook-dryad-final = 
			not(hasAnno(?HDF()));
			topdown(try(\LDC(String(<id>)) -> LDC(String(<concat-strings>["prefix_",<id>]))\));
			setAnno(|HDF())


	rules
		isConvertableIntType : b@ExprName(_) -> <id>
		where
			type-attr => ClassType(tn,_);
			where(
				<lookup-class> tn;
				get-superinterfaces(|<id>);
				fetch-elem(?InterfaceType(TypeName(PackageName([Id("test",Id("compilermods"))]),Id("IntErface")),None()))
			)


		convertIntType : b@ExprName(bname) -> c
		where
			isConvertableIntType;
			<type-attr>b => type@ClassType(tn@TypeName(_,_),_);
			!Invoke(
				Method(
					MethodName(
						ExprName(bname){Type(type)},
						Id("intValue")
					)
				),
				[]
			){Type(Int()),DeclaringClass(type),CompileTimeDeclaration(MethodName(tn,Id("intValue"),[],Int()))} => c

		emit-java-hook(s) : Assign(target,val) -> c
		where
			<type-attr> target => Int();
			<isConvertableIntType>val ;
			<emit-java(s)>Assign(target,<convertIntType>val) => c

	
		emit-java-hook(s) : Plus(a,b) -> c
		where
			(<isConvertableIntType>a <+ <isConvertableIntType>b);
			(<isConvertableIntType>a < !<convertIntType>a + !a) => a2;
			(<isConvertableIntType>b < !<convertIntType>b + !b) => b2;
			<emit-java(s)>Plus(a2,b2){Type(Int())} => c

}
definition
module languages/java-15/expressions/Priorities
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/expressions/Main

exports
  context-free priorities
      Expr "." "new" TypeArgs? Id TypeArgs? "(" {Expr ","}* ")" ClassBody? -> Expr
    > {right:
        Expr "++" -> Expr
        Expr "--" -> Expr
      } 

  context-free priorities
      {right:
        Expr "++" -> Expr
        Expr "--" -> Expr
      }
    > { "(" PrimType ")" Expr -> Expr    
        "(" RefType  ")" Expr -> Expr
      }

  context-free priorities
      "(" PrimType ")" Expr -> Expr
    > {left:
        Expr "*" Expr -> Expr
        Expr "/" Expr -> Expr
        Expr "%" Expr -> Expr
      } 

  context-free priorities
      "(" RefType ")" Expr -> Expr 
    > {
        "++" Expr -> Expr
        "--" Expr -> Expr
        "+"  Expr -> Expr
        "-"  Expr -> Expr
      }

  context-free priorities
    {
      Expr ArraySubscript -> ArrayAccess
      Expr "." Id -> FieldAccess
      Expr "." TypeArgs? Id -> MethodSpec
    }
  > {right:
      Expr "++" -> Expr
      Expr "--" -> Expr
    }
  > {
      "++" Expr -> Expr
      "--" Expr -> Expr
      "+"  Expr -> Expr
      "-"  Expr -> Expr
      "~"  Expr -> Expr
      "!"  Expr -> Expr
    }
  > {left:
      Expr "*" Expr -> Expr
      Expr "/" Expr -> Expr
      Expr "%" Expr -> Expr
    } 
  > {left:
      Expr "+" Expr -> Expr
      Expr "-" Expr -> Expr
    }
  > {left:
      Expr "<<"  Expr -> Expr
      Expr ">>"  Expr -> Expr
      Expr ">>>" Expr -> Expr
    }
  > {left:
      Expr "instanceof" RefType -> Expr
      Expr "<"   Expr -> Expr
      Expr ">"   Expr -> Expr
      Expr "<="  Expr -> Expr
      Expr ">="  Expr -> Expr
    }
  > {left:
      Expr "=="  Expr -> Expr
      Expr "!="  Expr -> Expr
    }
  >   Expr "&"   Expr -> Expr
  >   Expr "^"   Expr -> Expr
  >   Expr "|"   Expr -> Expr
  >   Expr "&&"  Expr -> Expr
  >   Expr "||"  Expr -> Expr
  >   Expr CondMid Expr -> Expr
  > {right:
      LHS "="    Expr -> Expr
      LHS "*="   Expr -> Expr
      LHS "/="   Expr -> Expr
      LHS "%="   Expr -> Expr
      LHS "+="   Expr -> Expr
      LHS "-="   Expr -> Expr
      LHS "<<="  Expr -> Expr
      LHS ">>="  Expr -> Expr
      LHS ">>>=" Expr -> Expr
      LHS "&="   Expr -> Expr
      LHS "^="   Expr -> Expr
      LHS "|="   Expr -> Expr
    }

module languages/java-15/expressions/Restrictions
exports
  lexical restrictions
    "+" -/- [\+]
    "-" -/- [\-]
    "/" -/- [\/]

module languages/java-15/expressions/AssignmentOperators
imports
  languages/java-15/expressions/Main

exports
  sorts LHS
  context-free syntax
    LHS "="    Expr -> Expr {cons("Assign")}
    LHS "*="   Expr -> Expr {cons("AssignMul")}
    LHS "/="   Expr -> Expr {cons("AssignDiv")}
    LHS "%="   Expr -> Expr {cons("AssignRemain")}
    LHS "+="   Expr -> Expr {cons("AssignPlus")}
    LHS "-="   Expr -> Expr {cons("AssignMinus")}
    LHS "<<="  Expr -> Expr {cons("AssignLeftShift")}
    LHS ">>="  Expr -> Expr {cons("AssignRightShift")}
    LHS ">>>=" Expr -> Expr {cons("AssignURightShift")}
    LHS "&="   Expr -> Expr {cons("AssignAnd")}
    LHS "^="   Expr -> Expr {cons("AssignExcOr")}
    LHS "|="   Expr -> Expr {cons("AssignOr")}

    ExprName    -> LHS
    FieldAccess -> LHS
    ArrayAccess -> LHS




module languages/java-15/expressions/BinaryOperators
imports
  languages/java-15/expressions/Main
  languages/java-15/types/Main

exports
  sorts CondMid
  context-free syntax
    Expr "instanceof" RefType -> Expr {cons("InstanceOf")}

    Expr "*"   Expr -> Expr  {left, cons("Mul")}
    Expr "/"   Expr -> Expr  {left, cons("Div")}
    Expr "%"   Expr -> Expr  {left, cons("Remain")}

    Expr "+"   Expr -> Expr  {left, cons("Plus")}
    Expr "-"   Expr -> Expr  {left, cons("Minus")}

    Expr "<<"  Expr -> Expr  {left, cons("LeftShift")}
    Expr ">>"  Expr -> Expr  {left, cons("RightShift")}
    Expr ">>>" Expr -> Expr  {left, cons("URightShift")}

    Expr "<"   Expr -> Expr  {left, cons("Lt")}
    Expr ">"   Expr -> Expr  {left, cons("Gt")}
    Expr "<="  Expr -> Expr  {left, cons("LtEq")}
    Expr ">="  Expr -> Expr  {left, cons("GtEq")}
    Expr "=="  Expr -> Expr  {left, cons("Eq")}
    Expr "!="  Expr -> Expr  {left, cons("NotEq")}

    Expr "&&"  Expr -> Expr  {left, cons("LazyAnd")}
    Expr "||"  Expr -> Expr  {left, cons("LazyOr")}

    Expr "&" Expr -> Expr {left, cons("And")}
    Expr "^" Expr -> Expr {left, cons("ExcOr")}
    Expr "|" Expr -> Expr {left, cons("Or")}

    %% todo JFR-30
    Expr CondMid Expr -> Expr {right, cons("Cond")}
    "?" Expr ":" -> CondMid {bracket}

module languages/java-15/expressions/UnaryOperators
imports 
  languages/java-15/expressions/Main
exports
  context-free syntax
    "+" Expr -> Expr {cons("Plus")}
    "-" Expr -> Expr {cons("Minus")}

    "++" Expr -> Expr {cons("PreIncr")}
    "--" Expr -> Expr {cons("PreDecr")}

    "~" Expr -> Expr {cons("Complement")}
    "!" Expr -> Expr {cons("Not")}

    "(" PrimType ")" Expr -> Expr {cons("CastPrim")}
    "(" RefType  ")" Expr -> Expr {cons("CastRef")}

module languages/java-15/expressions/Postfix
imports 
  languages/java-15/expressions/Main

exports
  context-free syntax
    ExprName  -> Expr
    Expr "++" -> Expr {cons("PostIncr")}
    Expr "--" -> Expr {cons("PostDecr")}

module languages/java-15/expressions/MethodInvocation
imports
  languages/java-15/expressions/Main

exports
  sorts MethodSpec
  context-free syntax
    MethodSpec "(" {Expr ","}* ")" -> Expr {cons("Invoke")}

                               MethodName -> MethodSpec {cons("Method")}
                    Expr "." TypeArgs? Id -> MethodSpec {cons("Method")}
                 "super" "." TypeArgs? Id -> MethodSpec {cons("SuperMethod")}
    TypeName "." "super" "." TypeArgs? Id -> MethodSpec {cons("QSuperMethod")}
                 AmbName "." TypeArgs  Id -> MethodSpec {cons("GenericMethod")}

  %% This priority forbids a Expr "." MethodSpec if the expression is a plain ExprName.
  %% This solves an ambiguity with the MethodName and AmbName . TypeArgs MethodSpecs.
  %% foo.bar.fred() results in a MethodName MethodSpec.
  %% (foo.bar).fred() results in the Expr. MethodSpec
  %% foo.bar.<T>fred() results in a GenericMethod
  context-free priorities
      Expr "." TypeArgs? Id -> MethodSpec
    > ExprName  -> Expr




module languages/java-15/expressions/ArrayAccess
imports
  languages/java-15/expressions/Main
exports
  sorts
    ArrayAccess
    ArraySubscript

  context-free syntax
    ArrayAccess -> Expr

    %% todo: JFR-29
    Expr ArraySubscript -> ArrayAccess {cons("ArrayAccess")}
    "[" Expr "]" -> ArraySubscript {bracket}

    ArrayCreationExpr ArraySubscript -> ArrayAccess {reject}

module languages/java-15/expressions/FieldAccess
imports
  languages/java-15/expressions/Main

exports
  sorts FieldAccess
  context-free syntax
    FieldAccess -> Expr

  context-free syntax

                    Expr "." Id -> FieldAccess {cons("Field")}
                ExprName "." Id -> FieldAccess {reject}
                 "super" "." Id -> FieldAccess {cons("SuperField")}
    TypeName "." "super" "." Id -> FieldAccess {cons("QSuperField")}

module languages/java-15/expressions/ArrayCreation
imports
  languages/java-15/expressions/Main

exports
  sorts
    ArrayCreationExpr
    ArrayBaseType
    Dim
    DimExpr

  context-free syntax
    ArrayCreationExpr     -> Expr

    "new" ArrayBaseType DimExpr+ Dim*  -> ArrayCreationExpr {cons("NewArray")}
    "new" ArrayBaseType Dim+ ArrayInit -> ArrayCreationExpr {cons("NewArray")}

    PrimType -> ArrayBaseType
    TypeName -> ArrayBaseType
    TypeName "<" "?" ">" -> ArrayBaseType {cons("UnboundWld")}

    "[" Expr "]" -> DimExpr {cons("Dim")}
    "[" "]"      -> Dim     {cons("Dim")}

module languages/java-15/expressions/ClassInstanceCreation
imports
  languages/java-15/expressions/Main
  languages/java-15/classes/ClassDeclarations

exports
  context-free syntax

             "new" TypeArgs? ClassOrInterfaceType "(" {Expr ","}* ")" ClassBody? -> Expr {cons("NewInstance")}
    Expr "." "new" TypeArgs? Id         TypeArgs? "(" {Expr ","}* ")" ClassBody? -> Expr {cons("QNewInstance")}

module languages/java-15/expressions/Primary
imports
  languages/java-15/lexical/literals/Main
  languages/java-15/names/Main
  languages/java-15/expressions/Main

exports
  %%%
   %% Section 15.8.1: Lexical Literals
   %%%
  sorts Literal
  context-free syntax
    Literal -> Expr {cons("Lit")}

    IntLiteral    -> Literal
    FloatLiteral  -> Literal
    BoolLiteral   -> Literal 
    CharLiteral   -> Literal
    StringLiteral -> Literal
    NullLiteral   -> Literal

  %%%
   %% Section 15.8.2: Class Literals
   %%%
  sorts ClassLiteral
  context-free syntax
    ClassLiteral -> Literal
    Type   "." "class" -> ClassLiteral {cons("Class")}
    "void" "." "class" -> ClassLiteral {cons("VoidClass")}

  %%%
   %% Section 15.8.3/4: (Qualified this)
   %%%
  context-free syntax
                 "this" -> Expr {cons("This")}
    TypeName "." "this" -> Expr {cons("QThis")}

  %%%
   %% Section 15.8.5: Parenthesized Expression
   %%%
  context-free syntax
    "(" Expr ")"          -> Expr {bracket}

module languages/java-15/expressions/Main
imports
  languages/java-15/expressions/Primary
  languages/java-15/expressions/ClassInstanceCreation
  languages/java-15/expressions/ArrayCreation
  languages/java-15/expressions/FieldAccess
  languages/java-15/expressions/ArrayAccess
  languages/java-15/expressions/MethodInvocation
  languages/java-15/expressions/Postfix
  languages/java-15/expressions/UnaryOperators
  languages/java-15/expressions/BinaryOperators
  languages/java-15/expressions/AssignmentOperators
  languages/java-15/expressions/Restrictions
  languages/java-15/expressions/Priorities

exports
  sorts
    Expr

module languages/java-15/statements/Main
imports
  languages/java-15/statements/Blocks
  languages/java-15/statements/LocalVariableDeclarations
  languages/java-15/statements/Statements




module languages/java-15/arrays/Main
imports
  languages/java-15/arrays/ArrayInitializers




module languages/java-15/interfaces/Main
imports
  languages/java-15/interfaces/InterfaceDeclarations
  languages/java-15/interfaces/AbstractMethodDeclarations
  languages/java-15/interfaces/AnnotationTypes
  languages/java-15/interfaces/Annotations




module languages/java-15/classes/Main
imports
  languages/java-15/classes/ClassDeclarations
  languages/java-15/classes/EnumDeclarations




module languages/java-15/packages/PackageDeclarations
imports
  languages/java-15/names/Main
  languages/java-15/interfaces/Annotations

exports
  sorts
    PackageDec

  context-free syntax
    Anno* "package" PackageName ";" -> PackageDec {cons("PackageDec")}

module languages/java-15/packages/ImportDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/names/Main

exports
  sorts
    ImportDec

  context-free syntax
    "import" TypeName                  ";"  -> ImportDec {cons("TypeImportDec")}
    "import" PackageName       "." "*" ";"  -> ImportDec {cons("TypeImportOnDemandDec")}
    "import" "static" TypeName "." Id  ";"  -> ImportDec {cons("StaticImportDec")}
    "import" "static" TypeName "." "*" ";"  -> ImportDec {cons("StaticImportOnDemandDec")}

module languages/java-15/interfaces/AnnotationTypes
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/classes/ClassDeclarations
  languages/java-15/classes/EnumDeclarations
  languages/java-15/interfaces/InterfaceDeclarations
  languages/java-15/interfaces/AbstractMethodDeclarations
  languages/java-15/interfaces/ConstantDeclarations
  languages/java-15/interfaces/Annotations

exports
  sorts
    AnnoDec
    AnnoDecHead

  context-free syntax
    AnnoDecHead "{" AnnoElemDec* "}" -> AnnoDec {cons("AnnoDec")}
    (Anno | InterfaceMod)* "@" "interface" Id -> AnnoDecHead {cons("AnnoDecHead")}

  sorts
    AnnoElemDec
    DefaultVal

  context-free syntax
    AbstractMethodMod* Type Id "(" ")" DefaultVal? ";" -> AnnoElemDec {cons("AnnoMethodDec")}

    ConstantDec  -> AnnoElemDec
    ClassDec     -> AnnoElemDec
    InterfaceDec -> AnnoElemDec
    EnumDec      -> AnnoElemDec
    AnnoDec      -> AnnoElemDec
    ";"          -> AnnoElemDec {cons("Semicolon")}

    "default" ElemVal -> DefaultVal {cons("DefaultVal")}

module languages/java-15/interfaces/AbstractMethodDeclarations
imports
  languages/java-15/lexical/Modifiers
  languages/java-15/names/Main
  languages/java-15/types/Main
  languages/java-15/classes/MethodDeclarations

exports
  sorts
    AbstractMethodDec
    AbstractMethodMod

  context-free syntax
    (Anno | AbstractMethodMod)* TypeParams? ResultType
      Id "(" {FormalParam ","}* ")" Throws? ";" -> AbstractMethodDec {cons("AbstractMethodDec")}

    (Anno | AbstractMethodMod)* TypeParams? ResultType
      Id "(" {FormalParam ","}* ")" Dim+ Throws? ";" -> AbstractMethodDec {cons("DeprAbstractMethodDec")}

    Public   -> AbstractMethodMod
    Abstract -> AbstractMethodMod





module languages/java-15/interfaces/ConstantDeclarations
imports
  languages/java-15/lexical/Modifiers
  languages/java-15/types/Main
  languages/java-15/classes/MethodDeclarations
  languages/java-15/interfaces/Annotations

exports
  sorts
    ConstantDec
    ConstantMod

  context-free syntax
    (Anno | ConstantMod)* Type {VarDec ","}+ ";" -> ConstantDec {cons("ConstantDec")}

    Public -> ConstantMod
    Static -> ConstantMod
    Final  -> ConstantMod




module languages/java-15/interfaces/InterfaceDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/names/Main
  languages/java-15/types/Main
  languages/java-15/classes/ClassDeclarations
  languages/java-15/classes/MethodDeclarations
  languages/java-15/interfaces/ConstantDeclarations
  languages/java-15/interfaces/AbstractMethodDeclarations
  languages/java-15/interfaces/AnnotationTypes
  languages/java-15/interfaces/Annotations

exports
  sorts
    InterfaceDec
    InterfaceDecHead
    ExtendsInterfaces
    InterfaceMemberDec
    InterfaceMod

  context-free syntax
    AnnoDec -> InterfaceDec

    InterfaceDecHead "{" InterfaceMemberDec* "}" -> InterfaceDec {cons("InterfaceDec")}

    (Anno | InterfaceMod)* "interface" Id TypeParams? ExtendsInterfaces? -> InterfaceDecHead {cons("InterfaceDecHead")}
    "extends" {InterfaceType ","}+ -> ExtendsInterfaces {cons("ExtendsInterfaces")}

  context-free syntax
    ConstantDec       -> InterfaceMemberDec
    AbstractMethodDec -> InterfaceMemberDec
    ClassDec          -> InterfaceMemberDec
    InterfaceDec      -> InterfaceMemberDec
    ";"               -> InterfaceMemberDec {cons("Semicolon")}

  context-free syntax
    Public         -> InterfaceMod
    Protected      -> InterfaceMod
    Private        -> InterfaceMod
    Abstract       -> InterfaceMod
    Static         -> InterfaceMod
    StrictFP       -> InterfaceMod




module languages/java-15/classes/EnumDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/classes/ClassDeclarations

exports
  sorts
    EnumDec
    EnumDecHead
    EnumBody
    EnumConst
    EnumConstArgs
    EnumBodyDecs

  context-free syntax
    EnumDecHead EnumBody -> EnumDec {cons("EnumDec")}

    (Anno | ClassMod)* "enum" Id Interfaces? -> EnumDecHead {cons("EnumDecHead")}

    "{" {EnumConst ","}*     EnumBodyDecs? "}" -> EnumBody {cons("EnumBody")}
    "{" {EnumConst ","}* "," EnumBodyDecs? "}" -> EnumBody {cons("EnumBody")}

    Id EnumConstArgs? ClassBody?  -> EnumConst {cons("EnumConst")}
    "(" {Expr ","}* ")"  -> EnumConstArgs {bracket}

    ";" ClassBodyDec* -> EnumBodyDecs {cons("EnumBodyDecs")}

module languages/java-15/classes/ConstructorDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/interfaces/Annotations
  languages/java-15/statements/Main
  languages/java-15/expressions/Main

exports
  sorts
    ConstrDec
    ConstrBody
    ConstrHead
    ConstrInv

  context-free syntax
    ConstrHead ConstrBody ->  ConstrDec {cons("ConstrDec")}
    (Anno | ConstrMod)* TypeParams? Id "(" {FormalParam ","}* ")" Throws? -> ConstrHead {cons("ConstrDecHead")}


    "{" ConstrInv? BlockStm* "}" -> ConstrBody {cons("ConstrBody")}

             TypeArgs? "this"  "(" {Expr ","}* ")" ";" -> ConstrInv {cons("AltConstrInv")}
             TypeArgs? "super" "(" {Expr ","}* ")" ";" -> ConstrInv {cons("SuperConstrInv")}
    Expr "." TypeArgs? "super" "(" {Expr ","}* ")" ";" -> ConstrInv {cons("QSuperConstrInv")}

  sorts ConstrMod
  context-free syntax  
    Public    -> ConstrMod
    Protected -> ConstrMod
    Private   -> ConstrMod




module languages/java-15/classes/StaticInitializers
imports
  languages/java-15/statements/Blocks

exports
  sorts
    StaticInit

  context-free syntax
    "static" Block -> StaticInit   {cons("StaticInit")}

module languages/java-15/classes/InstanceInitializers
imports
  languages/java-15/statements/Blocks

exports
  sorts
    InstanceInit

  context-free syntax
    Block -> InstanceInit {cons("InstanceInit")}

module languages/java-15/statements/Statements
imports
  languages/java-15/statements/LocalVariableDeclarations
  languages/java-15/statements/Blocks
  languages/java-15/expressions/Main

exports
  sorts
    Stm

  context-free syntax
    Block      -> Stm

  %%%
   %% Section 14.6: The Empty Statement
   %%%
  context-free syntax
    ";"        -> Stm {cons("Empty")}

  %%%
   %% Section 14.7: Labeled Statements
   %%%
  context-free syntax
    Id ":" Stm -> Stm {cons("Labeled")}

  %%%
   %% Section 14.8: Expressions Statements
   %%%
  context-free syntax
    Expr ";"   -> Stm {cons("ExprStm")}

  %%%
   %% Section 14.9: The If Statement
   %%%
  context-free syntax
    "if" "(" Expr ")" Stm             -> Stm {prefer, cons("If")}
    "if" "(" Expr ")" Stm  "else" Stm -> Stm {cons("If")}

  %%%
   %% Section 14.10: The Assert Statement
   %%%
  context-free syntax
    "assert" Expr          ";" -> Stm  {cons("AssertStm")}
    "assert" Expr ":" Expr ";" -> Stm  {cons("AssertStm")}


  %%%
   %% Section 14.11: The Switch Statement
   %%%
  sorts SwitchBlock SwitchGroup SwitchLabel
  context-free syntax
    "switch" "(" Expr ")" SwitchBlock -> Stm {cons("Switch")}
    "{" SwitchGroup* SwitchLabel* "}" -> SwitchBlock {cons("SwitchBlock")}
    SwitchLabel+ BlockStm+ -> SwitchGroup  {cons("SwitchGroup")}

    "case" Expr ":" -> SwitchLabel {cons("Case")}
    "default"   ":" -> SwitchLabel {cons("Default")}

  %%%
   %% Section 14.12: The While Statement
   %%%
  context-free syntax
    "while" "(" Expr ")" Stm -> Stm {cons("While")}

  %%%
   %% Section 14.13: The Do Statement
   %%%
  context-free syntax
  "do" Stm "while" "(" Expr ")" ";" -> Stm {cons("DoWhile")}


  %%%
   %% Section 14.14: The For Statement
   %%%
  context-free syntax
    "for" "(" LocalVarDec ";" Expr? ";" {Expr ","}* ")" Stm -> Stm {cons("For")}
    "for" "(" {Expr ","}* ";" Expr? ";" {Expr ","}* ")" Stm -> Stm {cons("For")}

    "for" "(" FormalParam ":" Expr ")" Stm -> Stm {cons("ForEach")}

  %%%
   %% Section 14.15: The Break Statement
   %%%
  context-free syntax
    "break"    Id? ";"   -> Stm {cons("Break")}

  %%%
   %% Section 14.16: The Continue Statement
   %%%
  context-free syntax
    "continue" Id? ";"   -> Stm {cons("Continue")}

  %%%
   %% Section 14.17: The Return Statement
   %%%
  context-free syntax
    "return"   Expr? ";" -> Stm {cons("Return")}

  %%%
   %% Section 14.18: The Throw Statement
   %%%
  context-free syntax
    "throw"    Expr  ";" -> Stm {cons("Throw")}

  %%%
   %% Section 14.19: The Synchronized Statement
   %%%
  context-free syntax
    "synchronized" "(" Expr ")" Block -> Stm {cons("Synchronized")}

  %%%
   %% Section 14.20: The Try Statement
   %%%
  sorts CatchClause
  context-free syntax
    "try" Block CatchClause+ -> Stm {cons("Try")}
    "try" Block CatchClause* "finally" Block -> Stm {cons("Try")}
    "catch" "(" FormalParam ")" Block -> CatchClause {cons("Catch")}

module languages/java-15/statements/LocalVariableDeclarations
imports
  languages/java-15/classes/MethodDeclarations
  languages/java-15/classes/FieldDeclarations

exports
  sorts
    LocalVarDecStm
    LocalVarDec

  context-free syntax
    LocalVarDec ";" -> LocalVarDecStm {prefer, cons("LocalVarDecStm")}
    (Anno | VarMod)* Type {VarDec ","}+ -> LocalVarDec {prefer, cons("LocalVarDec")}

module languages/java-15/statements/Blocks
imports
  languages/java-15/classes/ClassDeclarations
  languages/java-15/statements/LocalVariableDeclarations
  languages/java-15/statements/Statements

exports
  sorts
    BlockStm
    Block

  context-free syntax
    "{" BlockStm* "}" -> Block {cons("Block")}

    LocalVarDecStm  -> BlockStm 
    ClassDec        -> BlockStm {cons("ClassDecStm")}
    Stm             -> BlockStm




module languages/java-15/classes/MethodDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/types/Main
  languages/java-15/classes/FieldDeclarations
  languages/java-15/interfaces/Annotations
  languages/java-15/statements/Blocks

exports
  sorts
    MethodDec
    MethodDecHead
    ResultType

  context-free syntax
    MethodDecHead MethodBody -> MethodDec {cons("MethodDec")}

    (Anno | MethodMod)* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws?      -> MethodDecHead {cons("MethodDecHead")}
    (Anno | MethodMod)* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? -> MethodDecHead {cons("DeprMethodDecHead")}

    Type   -> ResultType
    "void" -> ResultType {cons("Void")}

  sorts FormalParam
  context-free syntax
    (Anno | VarMod)* Type       VarDecId -> FormalParam {cons("Param")}
    (Anno | VarMod)* Type "..." VarDecId -> FormalParam {cons("VarArityParam")}

  sorts VarMod
  context-free syntax
    Final -> VarMod

  sorts MethodMod
  context-free syntax
    Public         -> MethodMod
    Protected      -> MethodMod
    Private        -> MethodMod

    Abstract       -> MethodMod
    Static         -> MethodMod
    Final          -> MethodMod
    Synchronized   -> MethodMod
    Native         -> MethodMod
    StrictFP       -> MethodMod

  %%%
   %% Section 8.4.6: Method Throws
   %%%
  sorts
    Throws
    ExceptionType

  context-free syntax
    "throws" {ExceptionType ","}+ -> Throws {cons("ThrowsDec")}
    ClassType -> ExceptionType
    %% TypeVar -> ExceptionType

  %%%
   %% Section 8.4.7: Method Body
   %%% 
  sorts MethodBody
  context-free syntax
    Block -> MethodBody
    ";"   -> MethodBody {cons("NoMethodBody")}

module languages/java-15/arrays/ArrayInitializers
imports
  languages/java-15/classes/FieldDeclarations

exports
  sorts ArrayInit
  context-free syntax
    "{" {VarInit ","}*     "}" -> ArrayInit {cons("ArrayInit")}
    "{" {VarInit ","}* "," "}" -> ArrayInit {cons("ArrayInit")}

module languages/java-15/interfaces/Annotations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/names/Main
  languages/java-15/expressions/Main

exports
  sorts
    Anno
    ElemVal
    ElemValPair

  context-free syntax
    "@" TypeName "(" {ElemValPair ","}* ")" -> Anno {cons("Anno")}
    "@" TypeName "(" ElemVal ")"            -> Anno {cons("SingleElemAnno")}
    "@" TypeName                            -> Anno {cons("MarkerAnno")}

  context-free syntax  
    Id "=" ElemVal -> ElemValPair {cons("ElemValPair")}

    Expr -> ElemVal
    Anno -> ElemVal

    "{" {ElemVal ","}*     "}" -> ElemVal {cons("ElemValArrayInit")}
    "{" {ElemVal ","}* "," "}" -> ElemVal {cons("ElemValArrayInit")}

    %% Assignments are not allowed as element values.
    LHS "=" Expr -> ElemVal {reject}

module languages/java-15/classes/FieldDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/types/Main
  languages/java-15/interfaces/Annotations
  languages/java-15/arrays/ArrayInitializers
  languages/java-15/expressions/Main

exports
  sorts
    FieldDec
    VarDec
    VarDecId
    Dim
    VarInit

  context-free syntax
    (Anno | FieldMod)* Type { VarDec ","}+ ";" -> FieldDec {cons("FieldDec")}

    VarDecId             -> VarDec {cons("VarDec")}
    VarDecId "=" VarInit -> VarDec {cons("VarDec")}

    Id      -> VarDecId
    Id Dim+ -> VarDecId {cons("ArrayVarDecId")}

    "[" "]" -> Dim {cons("Dim")}

    Expr      -> VarInit
    ArrayInit -> VarInit

  sorts FieldMod
  context-free syntax
    Public    -> FieldMod
    Protected -> FieldMod
    Private   -> FieldMod

    Static    -> FieldMod
    Final     -> FieldMod
    Transient -> FieldMod
    Volatile  -> FieldMod




module languages/java-15/classes/ClassDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/types/ReferenceTypes
  languages/java-15/types/TypeVariables
  languages/java-15/classes/FieldDeclarations
  languages/java-15/classes/MethodDeclarations
  languages/java-15/classes/InstanceInitializers
  languages/java-15/classes/StaticInitializers
  languages/java-15/classes/ConstructorDeclarations
  languages/java-15/classes/EnumDeclarations
  languages/java-15/interfaces/InterfaceDeclarations

exports
  sorts
    ClassDec
    ClassBody
    ClassDecHead

  context-free syntax
    EnumDec -> ClassDec

    ClassDecHead ClassBody -> ClassDec {cons("ClassDec")}
    "{" ClassBodyDec* "}" -> ClassBody {cons("ClassBody")}

    (Anno | ClassMod)* "class" Id  TypeParams? Super? Interfaces? -> ClassDecHead {cons("ClassDecHead")}

  %% 8.1.1: Class Modifiers
  sorts ClassMod
  context-free syntax
    Abstract  -> ClassMod
    Public    -> ClassMod
    Protected -> ClassMod
    Private   -> ClassMod
    Static    -> ClassMod
    Final     -> ClassMod
    StrictFP  -> ClassMod

  %% 8.1.4: Superclasses and Subclasses
  sorts Super
  context-free syntax

    "extends" ClassType -> Super {cons("SuperDec")}

  %% 8.1.5: Superinterfaces
  sorts Interfaces
  context-free syntax
    "implements" {InterfaceType ","}+ -> Interfaces {cons("ImplementsDec")}


  %% 8.1.6: Class Body and Member Declarations
  sorts
    ClassBodyDec
    ClassMemberDec

  context-free syntax
    ClassMemberDec -> ClassBodyDec
    InstanceInit   -> ClassBodyDec
    StaticInit     -> ClassBodyDec
    ConstrDec      -> ClassBodyDec

  context-free syntax
    FieldDec     -> ClassMemberDec
    MethodDec    -> ClassMemberDec
    ClassDec     -> ClassMemberDec
    InterfaceDec -> ClassMemberDec
    ";"          -> ClassMemberDec {cons("Semicolon")}

module languages/java-15/packages/TypeDeclarations
imports
  languages/java-15/classes/ClassDeclarations
  languages/java-15/interfaces/InterfaceDeclarations

exports
  sorts
    TypeDec

  context-free syntax
    ClassDec      -> TypeDec
    InterfaceDec  -> TypeDec
    ";"           -> TypeDec {cons("Semicolon")}

module languages/java-15/packages/CompilationUnits
imports
  languages/java-15/packages/PackageDeclarations
  languages/java-15/packages/ImportDeclarations
  languages/java-15/packages/TypeDeclarations

exports
  sorts
    CompilationUnit

  context-free syntax
    PackageDec? ImportDec* TypeDec+ -> CompilationUnit   {cons("CompilationUnit")}

module languages/java-15/packages/Main
imports
  languages/java-15/packages/CompilationUnits
  languages/java-15/packages/ImportDeclarations
  languages/java-15/packages/PackageDeclarations




module languages/java-15/names/Main
imports
  languages/java-15/lexical/Identifiers
exports
  sorts PackageName
  context-free syntax
    {Id "."}+ -> PackageName {cons("PackageName")}

  sorts
    TypeName
    ExprName
    MethodName
    PackageOrTypeName
    AmbName

  context-free syntax
    Id             -> AmbName {cons("AmbName")}
    AmbName "." Id -> AmbName {cons("AmbName")}

    Id                       -> TypeName {cons("TypeName")}
    PackageOrTypeName "." Id -> TypeName {cons("TypeName")}

    Id             -> ExprName {cons("ExprName")}
    AmbName "." Id -> ExprName {cons("ExprName")}

    Id             -> MethodName  {cons("MethodName")}
    AmbName "." Id -> MethodName  {cons("MethodName")}

    Id                       -> PackageOrTypeName {cons("PackageOrTypeName")}
    PackageOrTypeName "." Id -> PackageOrTypeName {cons("PackageOrTypeName")}

module languages/java-15/types/ParameterizedTypes
imports
  languages/java-15/types/ReferenceTypes

exports
  sorts
    TypeArgs
    ActualTypeArg
    WildcardBound
    
  context-free syntax
    "<" {ActualTypeArg ","}+ ">" -> TypeArgs {cons("TypeArgs")}

    Type               -> ActualTypeArg
    "?" WildcardBound? -> ActualTypeArg {cons("Wildcard")}

    "extends" RefType -> WildcardBound {cons("WildcardUpperBound")}
    "super"   RefType -> WildcardBound {cons("WildcardLowerBound")}

module languages/java-15/types/TypeVariables
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/types/ReferenceTypes

exports
  sorts
    TypeParams
    TypeParam
    TypeBound
    TypeVarId
  
  context-free syntax
    TypeVarId TypeBound? -> TypeParam {cons("TypeParam")}
    
    "extends" {ClassOrInterfaceType "&"}+ -> TypeBound {cons("TypeBound")}
    "<" {TypeParam ","}+ ">" -> TypeParams {cons("TypeParams")}

    Id -> TypeVarId
    



module languages/java-15/types/ReferenceTypes
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/names/Main
  languages/java-15/types/Main  
  languages/java-15/types/ParameterizedTypes
  languages/java-15/types/TypeVariables


exports
  sorts
    RefType
    ClassOrInterfaceType
    ClassType
    InterfaceType
    TypeDecSpec
    ArrayType
    TypeVar

  context-free syntax
    ClassOrInterfaceType -> RefType
    ArrayType            -> RefType
    
    %% This production rule is highly ambiguous, since every
    %% TypeVar can be a ClassOrInterfaceType. A later disambiguation
    %% phase has to find out if a ClassOrInterfaceType is in fact
    %% a TypeVar.
    
    %% TypeVar -> RefType {avoid}

  context-free syntax
  
    %% ClassType and InterfaceType are ambiguous. We modify the
    %% production of ClassOrInterfaceType to make this ambiguity explicit.
    
    TypeDecSpec TypeArgs? -> ClassOrInterfaceType {cons("ClassOrInterfaceType")}
    TypeDecSpec TypeArgs? -> ClassType {cons("ClassType")}
    TypeDecSpec TypeArgs? -> InterfaceType {cons("InterfaceType")}

    TypeName -> TypeDecSpec
    TypeDecSpec TypeArgs "." Id -> TypeDecSpec {cons("Member")}
    
  context-free syntax    
    TypeVarId -> TypeVar {cons("TypeVar")}

  context-free syntax
    Type "[" "]" -> ArrayType  {cons("ArrayType")}

module languages/java-15/types/PrimitiveTypes
exports
  sorts
    PrimType
    NumType
    IntType  
    FloatType

  context-free syntax
    NumType   -> PrimType
    "boolean" -> PrimType {cons("Boolean")}

    IntType   -> NumType
    FloatType -> NumType

    "byte"   -> IntType   {cons("Byte")}
    "short"  -> IntType   {cons("Short")}
    "int"    -> IntType   {cons("Int")}
    "long"   -> IntType   {cons("Long")}
    "char"   -> IntType   {cons("Char")}
    "float"  -> FloatType {cons("Float")}
    "double" -> FloatType {cons("Double")}

module languages/java-15/types/Main
imports
  languages/java-15/types/PrimitiveTypes
  languages/java-15/types/ReferenceTypes
  languages/java-15/types/TypeVariables
  languages/java-15/types/ParameterizedTypes

exports
  sorts
    Type

  context-free syntax
    PrimType -> Type
    RefType  -> Type




module languages/java-15/lexical/literals/NullLiteral
exports
  sorts NullLiteral
  context-free syntax
    "null"  -> NullLiteral {cons("Null")}

module languages/java-15/lexical/literals/StringLiterals
imports
  languages/java-15/lexical/literals/EscapeSequences
  languages/java-15/lexical/UnicodeEscapes

exports
  sorts
    StringLiteral
    StringPart
    StringChars
    FooStringChars

  syntax
    StringLiteral -> <StringLiteral-CF>
    
    "\"" StringPart* "\"" -> StringLiteral {cons("String")}
    StringChars    -> StringPart {cons("Chars")}
    UnicodeEscape  -> StringPart
    EscapeSeq      -> StringPart

    <FooStringChars-LEX> -> StringChars
    ~[\"\\\n\13]+  -> <FooStringChars-LEX>

  restrictions
    StringChars -/- ~[\"\\\n\13]

module languages/java-15/lexical/literals/EscapeSequences
imports

exports
  sorts
    EscapeSeq
    NamedEscape
    OctaEscape
    LastOcta

  syntax
    OctaEscape  -> EscapeSeq
    NamedEscape -> EscapeSeq

    "\\" [btnfr\"\'\\]     -> NamedEscape {cons("NamedEscape")}
    "\\" LastOcta          -> OctaEscape  {cons("OctaEscape1")}
    "\\" [0-3] LastOcta    -> OctaEscape  {cons("OctaEscape2")}
    "\\" [4-7] [0-7]       -> OctaEscape  {cons("OctaEscape2")}
    "\\" [0-3] [0-7] [0-7] -> OctaEscape  {cons("OctaEscape3")}

    [0-7] -> LastOcta

  restrictions
    LastOcta -/- [0-7]

module languages/java-15/lexical/literals/CharacterLiterals
imports
  languages/java-15/lexical/literals/EscapeSequences
  languages/java-15/lexical/UnicodeEscapes

exports
  sorts
    CharLiteral
    CharContent
    SingleChar

  syntax
    CharLiteral   -> <CharLiteral-CF>

    "'" CharContent "'" -> CharLiteral {cons("Char")}
    SingleChar    -> CharContent {cons("Single")}
    UnicodeEscape -> CharContent
    EscapeSeq     -> CharContent

    ~[\r\n\'\\] -> SingleChar




module languages/java-15/lexical/literals/BooleanLiterals
exports
  sorts
    Bool
    BoolLiteral

  context-free syntax
    Bool -> BoolLiteral {cons("Bool")}
    "true"  -> Bool {cons("True")}
    "false" -> Bool {cons("False")}

module languages/java-15/lexical/literals/FloatingPointLiterals
exports
  sorts
    FloatLiteral
    DeciFloatLiteral
    HexaFloatLiteral      
  
  context-free syntax
    DeciFloatLiteral -> FloatLiteral {cons("Float")}
    HexaFloatLiteral -> FloatLiteral {cons("Float")}

  lexical syntax
    DeciFloatNumeral [fFdD]? -> DeciFloatLiteral
    HexaFloatNumeral [fFdD]? -> HexaFloatLiteral
    
    %% Reject plain integer literals as decimal float literals.
    %% A similar rejection for hexadecimal float literals is not
    %% required, since these always contain an exponent part.
    [0-9]+ -> DeciFloatLiteral {reject}

  lexical restrictions
    DeciFloatLiteral -/- [fFdD]
    HexaFloatLiteral -/- [fFdD]

  %%%
   %% Decimal Floating Point Numerals
   %%%
  sorts
    DeciFloatNumeral
    DeciFloatDigits
    DeciFloatExponentPart

  lexical syntax
    DeciFloatDigits DeciFloatExponentPart? -> DeciFloatNumeral

    [0-9]* "." [0-9]* -> DeciFloatDigits
           "."        -> DeciFloatDigits {reject}
    [0-9]+            -> DeciFloatDigits

    [eE] SignedInteger -> DeciFloatExponentPart
    
    [\+\-]? [0-9]+ -> SignedInteger    

  lexical restrictions
    DeciFloatDigits  -/- [0-9]
    DeciFloatExponentPart -/- [0-9]

  %%%
   %% Hexadecimal Floating Point Literals
   %%%
  sorts
    HexaFloatNumeral
    HexaSignificand
    BinaryExponent
    SignedInteger
    
  lexical syntax
    HexaSignificand BinaryExponent -> HexaFloatNumeral

    [0][xX] [0-9a-fA-F]+                  -> HexaSignificand
    [0][xX] [0-9a-fA-F]* "." [0-9a-fA-F]* -> HexaSignificand
    [0][xX]              "."              -> HexaSignificand {reject}

    [pP] SignedInteger -> BinaryExponent
  lexical restrictions
    HexaSignificand -/- [0-9a-fA-F]
    SignedInteger   -/- [0-9]

module languages/java-15/lexical/literals/IntegerLiterals
exports
  sorts
    IntLiteral
    DeciLiteral
    HexaLiteral
    OctaLiteral
    DeciNumeral
    HexaNumeral
    OctaNumeral

  context-free syntax
    DeciLiteral -> IntLiteral {cons("Deci")}
    HexaLiteral -> IntLiteral {cons("Hexa")}
    OctaLiteral -> IntLiteral {cons("Octa")}

  lexical syntax
    DeciNumeral [lL]? -> DeciLiteral
    HexaNumeral [lL]? -> HexaLiteral
    OctaNumeral [lL]? -> OctaLiteral

    "0" -> DeciNumeral
    [1-9][0-9]*  -> DeciNumeral
    [0][xX] [0-9a-fA-F]+ -> HexaNumeral
    [0]     [0-7]+       -> OctaNumeral

  lexical restrictions
    DeciNumeral -/- [0-9\.fFdD]
    HexaNumeral -/- [0-9a-fA-F]
    OctaNumeral -/- [0-7]

    DeciLiteral -/- [lL]
    HexaLiteral -/- [lL]
    OctaLiteral -/- [lL]

module languages/java-15/lexical/literals/Main
imports
  languages/java-15/lexical/literals/IntegerLiterals
  languages/java-15/lexical/literals/FloatingPointLiterals
  languages/java-15/lexical/literals/BooleanLiterals  
  languages/java-15/lexical/literals/CharacterLiterals  
  languages/java-15/lexical/literals/StringLiterals
  languages/java-15/lexical/literals/NullLiteral




module languages/java-15/lexical/Modifiers
exports
  sorts
    Public
    Private
    Protected
    Abstract
    Final
    Static
    Native
    Transient
    Volatile
    Synchronized
    StrictFP
    Modifier

  context-free syntax
    "public"       -> Public       {cons("Public")}
    "private"      -> Private      {cons("Private")}
    "protected"    -> Protected    {cons("Protected")}

    "abstract"     -> Abstract     {cons("Abstract")}
    "final"        -> Final        {cons("Final")}
    "static"       -> Static       {cons("Static")}
    "native"       -> Native       {cons("Native")}
    "transient"    -> Transient    {cons("Transient")}
    "volatile"     -> Volatile     {cons("Volatile")}
    "synchronized" -> Synchronized {cons("Synchronized")}
    "strictfp"     -> StrictFP     {cons("StrictFP")}

    Public       -> Modifier
    Private      -> Modifier
    Protected    -> Modifier
    Abstract     -> Modifier
    Final        -> Modifier
    Static       -> Modifier
    Native       -> Modifier
    Transient    -> Modifier
    Volatile     -> Modifier
    Synchronized -> Modifier
    StrictFP     -> Modifier




module languages/java-15/lexical/Keywords
exports
  sorts Keyword
  lexical syntax
    "abstract"      -> Keyword
    "assert"        -> Keyword
    "boolean"       -> Keyword
    "break"         -> Keyword
    "byte"          -> Keyword
    "case"          -> Keyword
    "catch"         -> Keyword
    "char"          -> Keyword
    "class"         -> Keyword
    "const"         -> Keyword
    "continue"      -> Keyword
    "default"       -> Keyword
    "do"            -> Keyword
    "double"        -> Keyword
    "else"          -> Keyword
    "enum"          -> Keyword
    "extends"       -> Keyword
    "final"         -> Keyword
    "finally"       -> Keyword
    "float"         -> Keyword
    "for"           -> Keyword
    "goto"          -> Keyword
    "if"            -> Keyword
    "implements"    -> Keyword
    "import"        -> Keyword
    "instanceof"    -> Keyword
    "int"           -> Keyword
    "interface"     -> Keyword
    "long"          -> Keyword
    "native"        -> Keyword
    "new"           -> Keyword
    "package"       -> Keyword
    "private"       -> Keyword
    "protected"     -> Keyword
    "public"        -> Keyword
    "return"        -> Keyword
    "short"         -> Keyword
    "static"        -> Keyword
    "strictfp"      -> Keyword
    "super"         -> Keyword
    "switch"        -> Keyword
    "synchronized"  -> Keyword
    "this"          -> Keyword
    "throw"         -> Keyword
    "throws"        -> Keyword
    "transient"     -> Keyword
    "try"           -> Keyword
    "void"          -> Keyword
    "volatile"      -> Keyword
    "while"         -> Keyword

  lexical restrictions

    "abstract"
    "assert"
    "boolean" 
    "break"   
    "byte"    
    "case"    
    "catch"   
    "char"     
    "class"
    "const"    
    "continue" 
    "default"  
    "do"       
    "double"   
    "else"     
    "enum"
    "extends"  
    "final"     
    "finally"   
    "float"     
    "for"       
    "goto"       
    "if"         
    "implements" 
    "import"     
    "instanceof" 
    "int"        
    "interface"  
    "long"       
    "native"     
    "new"        
    "package"    
    "private"    
    "protected"   
    "public"       
    "return"       
    "short"        
    "static"     
    "strictfp"
    "super"        
    "switch"       
    "synchronized" 
    "this"         
    "throw"        
    "throws"       
    "transient"    
    "try"          
    "void"         
    "volatile"     
    "while"       -/- [A-Za-z0-9\_\$]

module languages/java-15/lexical/Identifiers
imports
  languages/java-15/lexical/Keywords
exports
  sorts
    Id
    ID

  context-free syntax
    ID -> Id {cons("Id")}

  lexical syntax
    [A-Za-z\_\$][A-Za-z0-9\_\$]* -> ID
    
    Keyword -> ID {reject}
    "true"  -> ID {reject}
    "false" -> ID {reject}
    "null"  -> ID {reject}

  lexical restrictions
    ID -/- [a-zA-Z0-9\_\$]

module languages/java-15/lexical/Comments
imports
  languages/java-15/lexical/LineTerminators
exports
  sorts
    Comment
    EOLCommentChars
    CommentPart
    UnicodeEscape
    BlockCommentChars
    Asterisk
    EscEscChar
    EscChar

  lexical syntax
    Comment -> LAYOUT

    "//" EOLCommentChars LineTerminator -> Comment
    ~[\n\r]* -> EOLCommentChars

    "/*"  CommentPart* "*/" -> Comment
    "/**" CommentPart* "*/" -> Comment
    "/**/"                  -> Comment %% Strange javadoc comment

    BlockCommentChars -> CommentPart
    EscChar           -> CommentPart
    EscEscChar        -> CommentPart
    Asterisk          -> CommentPart
    UnicodeEscape     -> CommentPart

    ~[\*\\]+ -> BlockCommentChars

    "*"    -> Asterisk
    "\\\\" -> EscEscChar
    "\\"   -> EscChar

    "\\" [u]+ [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] -> UnicodeEscape

  lexical restrictions
    "/**"    -/- [\/]
    "/*"     -/- [\*]
    Asterisk -/- [\/]
    EscChar  -/- [\\u]

    BlockCommentChars -/- ~[\*\\]
    EOLCommentChars   -/- ~[\n\13]

  context-free restrictions
    LAYOUT?  -/- [\/].[\*]
    LAYOUT?  -/- [\/].[\/]

module languages/java-15/lexical/WhiteSpace
exports
  lexical syntax
    [\ \t\12\r\n] -> LAYOUT

  context-free restrictions
    LAYOUT? -/- [\ \t\12\n\r]

module languages/java-15/lexical/LineTerminators
exports
  sorts
    LineTerminator CarriageReturn EndOfFile

  lexical syntax
    [\n]           -> LineTerminator
    [\r][\n]       -> LineTerminator
    CarriageReturn -> LineTerminator
    EndOfFile      -> LineTerminator

    [\r] -> CarriageReturn

  lexical restrictions
    CarriageReturn -/- [\n]

  %% End of file is empty.
  lexical syntax    
    -> EndOfFile

  lexical restrictions
    EndOfFile -/- ~[]

module languages/java-15/lexical/UnicodeEscapes
exports
  sorts
    UnicodeEscape

  syntax
    "\\" [u]+ [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] -> UnicodeEscape {cons("UnicodeEscape")}

module languages/java-15/lexical/Main
imports
  languages/java-15/lexical/UnicodeEscapes
  languages/java-15/lexical/LineTerminators
  languages/java-15/lexical/WhiteSpace
  languages/java-15/lexical/Comments
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Keywords
  languages/java-15/lexical/Modifiers
  languages/java-15/lexical/literals/Main



module languages/java-15/Main
imports
  languages/java-15/lexical/Main
  languages/java-15/types/Main
  languages/java-15/names/Main
  languages/java-15/packages/Main
  languages/java-15/classes/Main
  languages/java-15/interfaces/Main
  languages/java-15/arrays/Main
  languages/java-15/statements/Main
  languages/java-15/expressions/Main




module languages/java/EmbeddedJava[E]
imports
  languages/java-15/Main

exports
  variables
    [ij]  [0-9\']*            -> DeciLiteral {prefer}
    [ij]  [\_] [a-zA-Z0-9\']* -> DeciLiteral {prefer}
    [xyz] [0-9\']*            -> ID          {prefer}
    [xyz] [\_] [a-zA-Z0-9\']* -> ID          {prefer}

  context-free restrictions
    ID -/- [\_a-zA-Z0-9\']

%%%
 %% Expressions
 %%%
exports

  %%%
   %% Variables for Expressions
   %%%
  variables
    "e"    [0-9\']*         -> Expr           {prefer}
    "e_" [a-zA-Z0-9\']*     -> Expr           {prefer}
    "e"    [0-9\']* "*"     -> {VarInit ","}* {prefer}
    "e_" [a-zA-Z0-9\']* "*" -> {VarInit ","}* {prefer}
    "e"    [0-9\']* "*"     -> {Expr ","}*    {prefer}
    "e_" [a-zA-Z0-9\']* "*" -> {Expr ","}*    {prefer}

  lexical syntax
    "e" [0-9\']*            -> ID {reject}
    "e_" [a-zA-Z0-9\']*     -> ID {reject}

  %%%
   %% Quotations for Expressions
   %%%
  context-free syntax
            "e" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
    "java:expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
         "expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
    "java"      "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
                "|[" Expr "]|"   -> E {cons("ToMetaExpr")}

    "var-init" "|[" VarInit "]|" -> E {cons("ToMetaExpr")}

%%%
 %% Statements
 %%%
exports

  %%%
   %% Variables for Statements
   %%%
  variables
    "stm"  [0-9\']*             -> Stm         {prefer}
    "stm_" [a-zA-Z0-9\']*       -> Stm         {prefer}
    "bstm" [0-9\']*             -> BlockStm    {prefer}
    "bstm_" [a-zA-Z0-9\']*      -> BlockStm    {prefer}
    "bstm" [0-9\']* "*"         -> BlockStm*   {prefer}    
    "bstm_" [a-zA-Z0-9\']* "*"  -> BlockStm*   {prefer}

  %%%
   %% Quotations for Statements
   %%%
  context-free syntax
    "java:bstm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
         "bstm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
    "java"       "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
                 "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}

    "java:bstm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}
         "bstm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}

    "java:block-stm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
         "block-stm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
    "java"            "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
                      "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}

    "java:block-stm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}
         "block-stm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}


    "java:stm"  "|[" Stm "]|" -> E {cons("ToMetaExpr")}
         "stm"  "|[" Stm "]|" -> E {cons("ToMetaExpr")}
         
         "switch-group" "|[" SwitchGroup "]|" -> E {cons("ToMetaListExpr")}         
    "java:switch-group" "|[" SwitchGroup "]|" -> E {cons("ToMetaListExpr")}
    
  %%%
   %% Anti Quotations for Statements
   %%%
  context-free syntax
    "~"       E  -> BlockStm  {cons("FromMetaExpr")}
    "~bstm:"  E  -> BlockStm  {cons("FromMetaExpr")}
    "~*"      E  -> BlockStm* {cons("FromMetaExpr")}
    "~bstm*:" E  -> BlockStm* {cons("FromMetaExpr")}

    "~stm:"   E  -> Stm {cons("FromMetaExpr"), prefer}
    "~"       E  -> Stm {cons("FromMetaExpr")}

    "~*"              E -> SwitchGroup* {cons("FromMetaExpr")}    
    "~switch-group*:" E -> SwitchGroup* {cons("FromMetaExpr")}    

    "~"               E -> SwitchGroup {cons("FromMetaExpr")}
    "~switch-group:"  E -> SwitchGroup {cons("FromMetaExpr")}

%%%
 %% Variable Declarations
 %%%

  %%%
   %% Variables for Variable Declarations
   %%%
  variables
    "lvdec" [0-9]*            -> LocalVarDec    {prefer}
    "lvdec_" [a-zA-Z0-9]*     -> LocalVarDec    {prefer}
     "vdec" [0-9]*            -> VarDec         {prefer}
     "vdec_" [a-zA-Z0-9]*     -> VarDec         {prefer}
     "vdec"  [0-9]* "*"       -> {VarDec ","}+  {prefer}
     "vdec_" [a-zA-Z0-9]* "*" -> {VarDec ","}+  {prefer}

  lexical syntax
    "lvdec"               -> ID {reject}
    "lvdec_" [a-zA-Z0-9]* -> ID {reject}
     "vdec"               -> ID {reject}
     "vdec_" [a-zA-Z0-9]* -> ID {reject}

  %%%
   %% Quotations for Local Variable Declarations
   %%%
  context-free syntax
    "java:lvdec"  "|[" LocalVarDec "]|" -> E {cons("ToMetaExpr")}
         "lvdec"  "|[" LocalVarDec "]|" -> E {cons("ToMetaExpr")}

    "java:vdec" "|[" VarDec "]|" -> E {cons("ToMetaExpr")}
         "vdec" "|[" VarDec "]|" -> E {cons("ToMetaExpr")}

  %%%
   %% Anti Quotations for Local Variable Declarations
   %%%
  context-free syntax

%%%
 %% LeftHandSide of Assignment
 %%%
exports

  %%%
   %% Variables for LeftHandSide of Assignment
   %%%
  variables
    "lhs" [0-9\']* -> LHS {prefer}
    "e"   [0-9\']* -> LHS {prefer}

  lexical syntax
    "lhs" [0-9\']* -> ID {reject}

%%%
 %% Types
 %%%
exports

  %%%
   %% Variables for Types
   %%%
  variables
    MetaTypeVar     -> Type     {prefer}
    MetaPrimTypeVar -> PrimType {prefer}
    MetaRefTypeVar  -> RefType  {prefer}

  lexical syntax
    "t"  [0-9\']*        -> MetaTypeVar
    "t_" [a-zA-Z0-9\']*  -> MetaTypeVar
    "ty" [0-9]*          -> MetaTypeVar
    "ty_" [a-zA-Z0-9\']* -> MetaTypeVar

    "primt"  [0-9]*        -> MetaPrimTypeVar
    "primt_" [a-zA-Z0-9]*  -> MetaPrimTypeVar
    "primty" [0-9]*        -> MetaPrimTypeVar
    "primty_" [a-zA-Z0-9]* -> MetaPrimTypeVar
    "reft"   [0-9]*        -> MetaRefTypeVar
    "reft_" [a-zA-Z0-9]*   -> MetaRefTypeVar
    "refty"  [0-9]*        -> MetaRefTypeVar
    "refty_" [a-zA-Z0-9]*  -> MetaRefTypeVar

    "t"  [0-9\']*          -> ID {reject}
    "t_" [a-zA-Z0-9]*      -> ID {reject}
    "ty" [0-9]*            -> ID {reject}
    "ty_" [a-zA-Z0-9]*     -> ID {reject}
    "primt"  [0-9]*        -> ID {reject}
    "primt_" [a-zA-Z0-9]*  -> ID  {reject}
    "primty" [0-9]*        -> ID {reject}
    "primty_" [a-zA-Z0-9]* -> ID {reject}
    "reft"   [0-9]*        -> ID {reject}
    "reft_" [a-zA-Z0-9]*   -> ID {reject}    
    "refty"  [0-9]*        -> ID {reject}
    "refty_" [a-zA-Z0-9]*  -> ID {reject}

  lexical restrictions
    MetaTypeVar -/- [a-zA-Z0-9\_\$\']

  %%%
   %% Quotation for Types
   %%%
  context-free syntax
            "t" "|[" Type "]|"   -> E {cons("ToMetaExpr")}
           "ty" "|[" Type "]|"   -> E {cons("ToMetaExpr")}

    "java:type" "|[" Type "]|"   -> E {cons("ToMetaExpr")}
         "type" "|[" Type "]|"   -> E {cons("ToMetaExpr")}
    "java"      "|[" Type "]|"   -> E {cons("ToMetaExpr")}
                "|[" Type "]|"   -> E {cons("ToMetaExpr")}

  %%%
   %% Anti-Quotation for Types
   %%%
  context-free syntax
    "~"       E -> Type {cons("FromMetaExpr")}
    "~type:"  E -> Type {cons("FromMetaExpr")}

%%%
 %% Names
 %%%
exports

  %%%
   %% Variables for Names
   %%%
  variables
    "ambname"  [0-9]*        -> AmbName    {prefer}
    "ambname_" [a-zA-Z0-9]*  -> AmbName    {prefer}
    "ename"    [0-9]*        -> ExprName   {prefer}
    "ename_" [a-zA-Z0-9]*    -> ExprName   {prefer}
    "fname"    [0-9]*        -> MethodName {prefer}
    "fname_" [a-zA-Z0-9]*    -> MethodName {prefer}
    "tname"    [0-9]*        -> TypeName   {prefer}
    "tname_" [a-zA-Z0-9]*    -> TypeName   {prefer}
    "pkgtname" [0-9]*        -> PackageOrTypeName  {prefer}
    "pkgtname_" [a-zA-Z0-9]* -> PackageOrTypeName  {prefer}
    "pkgname" [0-9]*         -> PackageName  {prefer}
    "pkgname_" [a-zA-Z0-9]*  -> PackageName  {prefer}

  %%%
   %% Quotations for Names
   %%%
  context-free syntax
    "ambname"  "|[" AmbName    "]|" -> E {cons("ToMetaExpr")}
    "ename"    "|[" ExprName   "]|" -> E {cons("ToMetaExpr")}
    "fname"    "|[" MethodName "]|" -> E {cons("ToMetaExpr")}
    "tname"    "|[" TypeName   "]|" -> E {cons("ToMetaExpr")}
    "pkgtname" "|[" PackageOrTypeName "]|" -> E {cons("ToMetaExpr")}

%%%
 %% Modifiers
 %%%
exports

  %%%
   %% Variables for Modifiers
   %%%
  variables
     "mod" [0-9]*            -> MethodMod  {prefer}
     "mod_" [a-zA-Z0-9]*     -> MethodMod  {prefer}
     "mod" [0-9]* "*"        -> (Anno | MethodMod)* {prefer}
     "mod_" [a-zA-Z0-9]* "*" -> (Anno | MethodMod)* {prefer}
     
     "mod" [0-9]*            -> ClassMod  {prefer}
     "mod_" [a-zA-Z0-9]*     -> ClassMod  {prefer}
     "mod" [0-9]* "*"        -> (Anno | ClassMod)* {prefer}
     "mod_" [a-zA-Z0-9]* "*" -> (Anno | ClassMod)* {prefer}
     
     "mod" [0-9]*            -> ConstrMod  {prefer}
     "mod_" [a-zA-Z0-9]*     -> ConstrMod  {prefer}
     "mod" [0-9]* "*"        -> (Anno | ConstrMod)* {prefer}
     "mod_" [a-zA-Z0-9]* "*" -> (Anno | ConstrMod)* {prefer}
     
     "mod" [0-9]*            -> VarMod  {prefer}
     "mod_" [a-zA-Z0-9]*     -> VarMod  {prefer}
     "mod" [0-9]* "*"        -> (Anno | VarMod)* {prefer}
     "mod_" [a-zA-Z0-9]* "*" -> (Anno | VarMod)* {prefer}

     "mod" [0-9]*            -> FieldMod  {prefer}
     "mod_" [a-zA-Z0-9]*     -> FieldMod  {prefer}
     "mod" [0-9]* "*"        -> (Anno | FieldMod)* {prefer}
     "mod_" [a-zA-Z0-9]* "*" -> (Anno | FieldMod)* {prefer}

  %%%
   %% Quotations for Modifiers
   %%%
  context-free syntax
           "|[" Modifier "]|" -> E {cons("ToMetaExpr")}
    "mod"  "|[" Modifier "]|" -> E {cons("ToMetaExpr")}

    "anno" "|[" Anno "]|" -> E {cons("ToMetaExpr")}


%%%
 %% Formal Parameters
 %%%
exports

  %%%
   %% Variables for Formal Parameters
   %%%
  variables
     "param" [0-9]*            -> FormalParam  {prefer}
     "param_" [a-zA-Z0-9]*     -> FormalParam  {prefer}
     "param" [0-9]* "*"        -> {FormalParam ","}*  {prefer}
     "param_" [a-zA-Z0-9]* "*" -> {FormalParam ","}* {prefer}

  %%%
   %% Quotations for Formal Parameters
   %%%
  context-free syntax

         "param"  "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
    "java:param"  "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}

         "param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
    "java:param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}

    "java:formal-param" "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
         "formal-param" "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
    "java"              "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
                        "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}

    "java:formal-param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
         "formal-param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
    "java"               "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
                         "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}

  %%%
   %% Anti Quotations for Formal Parameters
   %%%
  context-free syntax
    "~"  E  ->  FormalParam       {cons("FromMetaExpr")}
    "~*" E  -> {FormalParam ","}* {cons("FromMetaExpr")}

%%%
 %% Package Declarations
 %%%
exports

  %%%
   %% Quotations
   %%%
  context-free syntax
    "java:package-dec" "|[" PackageDec  "]|" -> E {cons("ToMetaExpr")}
         "package-dec" "|[" PackageDec  "]|" -> E {cons("ToMetaExpr")}
                       "|[" PackageDec  "]|" -> E {cons("ToMetaExpr")}

    "java:package-dec?" "|[" PackageDec? "]|" -> E {cons("ToMetaExpr")}
         "package-dec?" "|[" PackageDec? "]|" -> E {cons("ToMetaExpr")}

  %%%
   %% Anti Quotations
   %%%
  context-free syntax
    "~package-dec:"  E -> PackageDec {cons("FromMetaExpr")}
    "~package-dec?:" E -> PackageDec? {cons("FromMetaExpr")}

%%%
 %% Import Declarations
 %%%
exports

  %%%
   %% Quotations for Import Declarations
   %%%
  context-free syntax

    "java:import-dec"  "|[" ImportDec  "]|" -> E {cons("ToMetaExpr")}
         "import-dec"  "|[" ImportDec  "]|" -> E {cons("ToMetaExpr")}
                       "|[" ImportDec  "]|" -> E {cons("ToMetaExpr")}

    "java:import-dec*" "|[" ImportDec* "]|" -> E {cons("ToMetaListExpr")}
         "import-dec*" "|[" ImportDec* "]|" -> E {cons("ToMetaListExpr")}

  %%%
   %% Anti Quotations for Import Declarations
   %%%
  context-free syntax

    "~import-dec:"  E  -> ImportDec  {cons("FromMetaExpr")}
    "~import-dec*:" E  -> ImportDec* {cons("FromMetaExpr")}

%%%
 %% Must be cleaned up
 %%%
exports
  context-free syntax
            "e" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
    "java:expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
         "expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
    "java"      "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
                "|[" Expr "]|"   -> E {cons("ToMetaExpr")}

    "java:compilation-unit" "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}
         "compilation-unit" "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}
    "java"                  "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}
                            "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}

    "java:importdecl" "|[" ImportDec "]|"  -> E {cons("ToMetaExpr")}
         "importdecl" "|[" ImportDec "]|"  -> E {cons("ToMetaExpr")}
    "java"            "|[" ImportDec "]|"  -> E {cons("ToMetaExpr")}

    "java:type-dec" "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}
         "type-dec" "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}
    "java"          "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}
                    "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}

    "java:class-body-dec" "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}
         "class-body-dec" "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}
    "java"                "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}
                          "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}

    "java:interface-member-dec" "|[" InterfaceMemberDec  "]|" -> E {cons("ToMetaExpr")}
         "interface-member-dec" "|[" InterfaceMemberDec  "]|" -> E {cons("ToMetaExpr")}

    "java:constant-dec" "|[" ConstantDec  "]|" -> E {cons("ToMetaExpr")}
         "constant-dec" "|[" ConstantDec  "]|" -> E {cons("ToMetaExpr")}

    "java:class-body-dec*" "|[" ClassBodyDec* "]|" -> E {cons("ToMetaExpr")}
         "class-body-dec*" "|[" ClassBodyDec* "]|" -> E {cons("ToMetaExpr")}
    "java"                 "|[" ClassBodyDec* "]|" -> E {cons("ToMetaExpr")}
                           "|[" ClassBodyDec* "]|" -> E {cons("ToMetaListExpr")}

    "java:stm" "|["  Stm "]|" -> E {cons("ToMetaExpr")}
         "stm" "|["  Stm "]|" -> E {cons("ToMetaExpr")}

    "java:imember-dec" "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}
         "imember-dec" "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}
    "java"             "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}
                       "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}

    "java:imember-dec*" "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}
         "imember-dec*" "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}
    "java"              "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}
                        "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}

  %% Anti-quotation
  context-free syntax

    "~"      E -> Name {cons("FromMetaExpr")}
    "~name:" E -> Name {cons("FromMetaExpr")}
    "~*:"    E -> Name {cons("FromMetaExpr")}

    "~"     E     -> Id   {cons("FromMetaExpr")}
    "~id:"  E     -> Id   {cons("FromMetaExpr")}
    "~idd:" E ":" -> Id   {cons("FromMetaExpr")}

    "~x:" E -> ID {cons("FromMetaExpr")}

    "~"  E -> TypeParam        {cons("FromMetaExpr")}
    "~*" E -> {TypeParam ","}+ {cons("FromMetaExpr")}

    "~*" E -> {ExceptionType ","}* {cons("FromMetaExpr")}

    "~"      E  ->  Expr {cons("FromMetaExpr")}
    "~e:"    E  ->  Expr {prefer, cons("FromMetaExpr")}
    "~expr:" E  ->  Expr {prefer, cons("FromMetaExpr")}

    "~*" E      -> {Expr ","}*    {cons("FromMetaExpr")}
    "~*" E      -> {VarInit ","}* {cons("FromMetaExpr")}

    "~"  E  -> TypeDec  {cons("FromMetaExpr")}
    "~*" E  -> TypeDec* {cons("FromMetaExpr")}

    "~"  E  -> ClassBodyDec  {cons("FromMetaExpr")}
    "~*" E  -> ClassBodyDec* {cons("FromMetaExpr")}

    "~"  E  -> InterfaceMemberDec  {cons("FromMetaExpr")}
    "~*" E  -> InterfaceMemberDec* {cons("FromMetaExpr")}

    "~i:"      E -> DeciLiteral   {cons("FromMetaExpr")}
    "~deci:"   E -> DeciLiteral   {cons("FromMetaExpr")}
    "~hexa:"   E -> HexaLiteral   {cons("FromMetaExpr")}
    "~octa:"   E -> OctaLiteral   {cons("FromMetaExpr")}
    "~float:"  E -> FloatLiteral  {cons("FromMetaExpr")}
    "~string:" E -> StringLiteral {cons("FromMetaExpr")}
    "~char:"   E -> CharLiteral   {cons("FromMetaExpr")}

  syntax
    "~" <E-CF> -> StringChars {cons("FromMetaExpr"), prefer}
    "~" <E-CF> <LAYOUT?-CF> -> SingleChar  {cons("FromMetaExpr"), prefer}

module languages/java/EmbeddedJavaMix[Ctx0 E]
imports languages/java/EmbeddedJava[E]
          [ Name                  => Name[[Ctx0]]
            MetaRefTypeVar        => MetaRefTypeVar[[Ctx0]]
            MetaPrimTypeVar       => MetaPrimTypeVar[[Ctx0]]
            MetaTypeVar           => MetaTypeVar[[Ctx0]]
            CompilationUnit       => CompilationUnit[[Ctx0]]
            TypeDec               => TypeDec[[Ctx0]]
            ImportDec             => ImportDec[[Ctx0]]
            PackageDec            => PackageDec[[Ctx0]]
            ElemVal               => ElemVal[[Ctx0]]
            ElemValPair           => ElemValPair[[Ctx0]]
            Anno                  => Anno[[Ctx0]]
            LHS                   => LHS[[Ctx0]]
            CondMid               => CondMid[[Ctx0]]
            ArraySubscript        => ArraySubscript[[Ctx0]]
            DimExpr               => DimExpr[[Ctx0]]
            ArrayBaseType         => ArrayBaseType[[Ctx0]]
            ArrayCreationExpr     => ArrayCreationExpr[[Ctx0]]
            ClassMemberDec        => ClassMemberDec[[Ctx0]]
            ClassBodyDec          => ClassBodyDec[[Ctx0]]
            Interfaces            => Interfaces[[Ctx0]]
            Super                 => Super[[Ctx0]]
            ClassMod              => ClassMod[[Ctx0]]
            ClassDecHead          => ClassDecHead[[Ctx0]]
            ClassBody             => ClassBody[[Ctx0]]
            ClassDec              => ClassDec[[Ctx0]]
            InterfaceMod          => InterfaceMod[[Ctx0]]
            InterfaceMemberDec    => InterfaceMemberDec[[Ctx0]]
            ExtendsInterfaces     => ExtendsInterfaces[[Ctx0]]
            InterfaceDecHead      => InterfaceDecHead[[Ctx0]]
            InterfaceDec          => InterfaceDec[[Ctx0]]
            DefaultVal            => DefaultVal[[Ctx0]]
            AnnoElemDec           => AnnoElemDec[[Ctx0]]
            AnnoDecHead           => AnnoDecHead[[Ctx0]]
            AnnoDec               => AnnoDec[[Ctx0]]
            AbstractMethodMod     => AbstractMethodMod[[Ctx0]]
            AbstractMethodDec     => AbstractMethodDec[[Ctx0]]
            ConstantMod           => ConstantMod[[Ctx0]]
            ConstantDec           => ConstantDec[[Ctx0]]
            EnumBodyDecs          => EnumBodyDecs[[Ctx0]]
            EnumConstArgs         => EnumConstArgs[[Ctx0]]
            EnumConst             => EnumConst[[Ctx0]]
            EnumBody              => EnumBody[[Ctx0]]
            EnumDecHead           => EnumDecHead[[Ctx0]]
            EnumDec               => EnumDec[[Ctx0]]
            ConstrMod             => ConstrMod[[Ctx0]]
            ConstrInv             => ConstrInv[[Ctx0]]
            ConstrBody            => ConstrBody[[Ctx0]]
            ConstrHead            => ConstrHead[[Ctx0]]
            ConstrDec             => ConstrDec[[Ctx0]]
            StaticInit            => StaticInit[[Ctx0]]
            InstanceInit          => InstanceInit[[Ctx0]]
            MethodBody            => MethodBody[[Ctx0]]
            ExceptionType         => ExceptionType[[Ctx0]]
            Throws                => Throws[[Ctx0]]
            MethodMod             => MethodMod[[Ctx0]]
            VarMod                => VarMod[[Ctx0]]
            FormalParam           => FormalParam[[Ctx0]]
            ResultType            => ResultType[[Ctx0]]
            MethodDecHead         => MethodDecHead[[Ctx0]]
            MethodDec             => MethodDec[[Ctx0]]
            BlockStm              => BlockStm[[Ctx0]]
            Block                 => Block[[Ctx0]]
            CatchClause           => CatchClause[[Ctx0]]
            SwitchLabel           => SwitchLabel[[Ctx0]]
            SwitchGroup           => SwitchGroup[[Ctx0]]
            SwitchBlock           => SwitchBlock[[Ctx0]]
            Stm                   => Stm[[Ctx0]]
            LocalVarDec           => LocalVarDec[[Ctx0]]
            LocalVarDecStm        => LocalVarDecStm[[Ctx0]]
            FieldMod              => FieldMod[[Ctx0]]
            VarInit               => VarInit[[Ctx0]]
            Dim                   => Dim[[Ctx0]]
            VarDecId              => VarDecId[[Ctx0]]
            VarDec                => VarDec[[Ctx0]]
            FieldDec              => FieldDec[[Ctx0]]
            ArrayInit             => ArrayInit[[Ctx0]]
            ClassLiteral          => ClassLiteral[[Ctx0]]
            Literal               => Literal[[Ctx0]]
            Type                  => Type[[Ctx0]]
            ArrayType             => ArrayType[[Ctx0]]
            TypeVar               => TypeVar[[Ctx0]]
            TypeDecSpec           => TypeDecSpec[[Ctx0]]
            InterfaceType         => InterfaceType[[Ctx0]]
            ClassType             => ClassType[[Ctx0]]
            ClassOrInterfaceType  => ClassOrInterfaceType[[Ctx0]]
            RefType               => RefType[[Ctx0]]
            TypeVarId             => TypeVarId[[Ctx0]]
            TypeParams            => TypeParams[[Ctx0]]
            TypeBound             => TypeBound[[Ctx0]]
            TypeParam             => TypeParam[[Ctx0]]
            WildcardBound         => WildcardBound[[Ctx0]]
            ActualTypeArg         => ActualTypeArg[[Ctx0]]
            TypeArgs              => TypeArgs[[Ctx0]]
            PackageOrTypeName     => PackageOrTypeName[[Ctx0]]
            MethodName            => MethodName[[Ctx0]]
            ExprName              => ExprName[[Ctx0]]
            TypeName              => TypeName[[Ctx0]]
            AmbName               => AmbName[[Ctx0]]
            PackageName           => PackageName[[Ctx0]]
            FloatType             => FloatType[[Ctx0]]
            IntType               => IntType[[Ctx0]]
            NumType               => NumType[[Ctx0]]
            PrimType              => PrimType[[Ctx0]]
            NullLiteral           => NullLiteral[[Ctx0]]
            FooStringChars        => FooStringChars[[Ctx0]]
            StringChars           => StringChars[[Ctx0]]
            StringPart            => StringPart[[Ctx0]]
            StringLiteral         => StringLiteral[[Ctx0]]
            SingleChar            => SingleChar[[Ctx0]]
            CharContent           => CharContent[[Ctx0]]
            CharLiteral           => CharLiteral[[Ctx0]]
            LastOcta              => LastOcta[[Ctx0]]
            OctaEscape            => OctaEscape[[Ctx0]]
            NamedEscape           => NamedEscape[[Ctx0]]
            EscapeSeq             => EscapeSeq[[Ctx0]]
            Bool                  => Bool[[Ctx0]]
            BoolLiteral           => BoolLiteral[[Ctx0]]
            BinaryExponent        => BinaryExponent[[Ctx0]]
            HexaSignificand       => HexaSignificand[[Ctx0]]
            HexaFloatNumeral      => HexaFloatNumeral[[Ctx0]]
            SignedInteger         => SignedInteger[[Ctx0]]
            DeciFloatExponentPart => DeciFloatExponentPart[[Ctx0]]
            DeciFloatDigits       => DeciFloatDigits[[Ctx0]]
            DeciFloatNumeral      => DeciFloatNumeral[[Ctx0]]
            FloatLiteral          => FloatLiteral[[Ctx0]]
            HexaFloatLiteral      => HexaFloatLiteral[[Ctx0]]
            DeciFloatLiteral      => DeciFloatLiteral[[Ctx0]]
            IntLiteral            => IntLiteral[[Ctx0]]
            OctaNumeral           => OctaNumeral[[Ctx0]]
            HexaNumeral           => HexaNumeral[[Ctx0]]
            DeciNumeral           => DeciNumeral[[Ctx0]]
            OctaLiteral           => OctaLiteral[[Ctx0]]
            HexaLiteral           => HexaLiteral[[Ctx0]]
            DeciLiteral           => DeciLiteral[[Ctx0]]
            Modifier              => Modifier[[Ctx0]]
            StrictFP              => StrictFP[[Ctx0]]
            Synchronized          => Synchronized[[Ctx0]]
            Volatile              => Volatile[[Ctx0]]
            Transient             => Transient[[Ctx0]]
            Native                => Native[[Ctx0]]
            Static                => Static[[Ctx0]]
            Final                 => Final[[Ctx0]]
            Abstract              => Abstract[[Ctx0]]
            Protected             => Protected[[Ctx0]]
            Private               => Private[[Ctx0]]
            Public                => Public[[Ctx0]]
            Id                    => Id[[Ctx0]]
            ID                    => ID[[Ctx0]]
            Keyword               => Keyword[[Ctx0]]
            ArrayAccess           => ArrayAccess[[Ctx0]]
            FieldAccess           => FieldAccess[[Ctx0]]
            MethodSpec            => MethodSpec[[Ctx0]]
            Expr                  => Expr[[Ctx0]] ]


module Stratego-Sugar-Overlays
imports
  Stratego-Core-Identifiers
  Stratego-Sugar-Terms

exports
  sorts Overlay
  context-free syntax
    Id 			 "=" Term 	-> Overlay {cons("OverlayNoArgs")}
    Id "(" {Id ","}* ")" "=" Term 	-> Overlay {cons("Overlay")}

module Stratego-Sugar-DynamicRules
imports
  Stratego-Core-Identifiers
  Stratego-Sugar-Strategies
  Stratego-Sugar-Rules

exports
 
  sorts ScopeLabels
  context-free syntax

    "{|" ScopeLabels ":" Strategy "|}" -> Strategy {cons("DynRuleScope")}

    {DynRuleScopeId ","}*   -> ScopeLabels
    "~" Term		    -> ScopeLabels {cons("ScopeLabels")}

  sorts DynRuleDef DynRuleId DynRuleScopeId RuleDec
  context-free syntax

    "rules" "(" DynRuleDef* ")" -> Strategy {cons("GenDynRules")}

    Id "+" Term                 -> DynRuleDef {cons("AddScopeLabel")} 
    DynRuleId ":-"  Term        -> DynRuleDef {cons("UndefineDynRule")}
    DynRuleId ":"   Rule        -> DynRuleDef {cons("SetDynRule")}
    DynRuleId ":+"  Rule        -> DynRuleDef {cons("AddDynRule")}
    DynRuleId ":"   Term        -> DynRuleDef {cons("SetDynRuleMatch")}

    DynRuleId ":="  Term        -> DynRuleDef {cons("DynRuleAssign")}
    DynRuleId ":+="  Term       -> DynRuleDef {cons("DynRuleAssignAdd")}

    DynRuleId ":"   Rule "depends" "on" Term -> DynRuleDef {cons("SetDynRuleDepends")}

    RuleDec "." Term            -> DynRuleId {cons("LabeledDynRuleId")}
    RuleDec "+" Term            -> DynRuleId {cons("AddLabelDynRuleId")}
    RuleDec                     -> DynRuleId {cons("DynRuleId")}

    Id "." Term                 -> DynRuleScopeId {cons("LabeledDynRuleScopeId")}
    Id                          -> DynRuleScopeId {cons("DynRuleScopeId")}

  context-free syntax

    Id                          -> RuleDec {cons("RDecNoArgs")}
    Id "(" {Typedid ","}* ")"   -> RuleDec {cons("RDec")}
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"   -> RuleDec {cons("RDecT")}

  sorts RuleNames
  context-free syntax
    {Id ","}*				  -> RuleNames
    "~" Term				  -> RuleNames {cons("RuleNames")}

    "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}

  syntax
    %% no space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% 1 space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% no space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

    %% 1 space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}


  context-free syntax
    Strategy "/" RuleNames"\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
    Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}

    Strategy "/" RuleNames "\\" 
                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}

  priorities
    <StrategyAngle-CF> <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("BA")}
  > {

    %% no space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% 1 space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% no space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

    %% 1 space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

    }
  > <Strategy-CF> <LAYOUT?-CF> "=>" <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("AM")}

  context-free priorities
    StrategyAngle Term 		          -> Strategy {cons("BA")}
  > "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
  > Strategy "/" RuleNames "\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
  > Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
  > Strategy "/" RuleNames "\\" 
                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}

module Stratego-Sugar-Rules
imports Stratego-Sugar-Strategies
exports

  sorts RuleDef
  context-free syntax
    Id ":" Rule 				-> RuleDef {cons("RDefNoArgs")}

    Id "(" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDef")}

    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDefT")}

  sorts Rule RuleCond
  context-free syntax
    Term "->" Term           	    -> Rule {cons("RuleNoCond")} %% backward comp.
    Term "->" Term "where" Strategy -> Rule {cons("Rule")}       %% backward comp.
    Term "->" Term RuleCond+	    -> Rule {cons("Rule"), avoid}

    "where" Strategy -> RuleCond {cons("WhereClause")}
    "with"  Strategy -> RuleCond {cons("WithClause")}

module Stratego-Sugar-Strategies
imports
  Stratego-Core-Strategies
  Stratego-Sugar-Terms
  Stratego-Sugar-Constants
  Stratego-Sugar-Signatures

exports
  context-free syntax
    Id  		      "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}

  context-free syntax
    ID 				  	  -> Typedid {cons("DefaultVarDec")}

  sorts Rule

  sorts StrategyParen StrategyCurly StrategyAngle
  context-free syntax

    %% Abstraction

    SVar "(" {Strategy ","}* ")" 	  -> Strategy {cons("Call")}

    %% Match and build

    "{" Strategy "}" 			  -> Strategy {cons("ScopeDefault")}

     %%"<" Strategy ">" Term 		  -> Strategy {cons("BA")}
     StrategyAngle Term 		  -> Strategy {cons("BA")}
     "<" Strategy ">"			  -> StrategyAngle {bracket} %% {cons("AngleStrat")}

    %% Combinators

    Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}

    "rec" Id "(" Strategy ")" 		  -> Strategy {cons("Rec")}

    "not"   "(" Strategy ")" 		  -> Strategy {cons("Not")}
    "where" "(" Strategy ")" 		  -> Strategy {cons("Where")}
    "with"  "(" Strategy ")" 		  -> Strategy {cons("With"), prefer}
    "test"  "(" Strategy ")" 		  -> Strategy {cons("Test")}

    %% Primitives

    "prim" "(" String ")" 		  -> Strategy {cons("PrimNoArgs")}
    "prim" "(" String "," {Term ","}* ")" -> Strategy {cons("Prim")}

    %% Congruence operators

    String 				  -> Strategy {cons("StrCong")}
    Int 				  -> Strategy {cons("IntCong")}
    Real 				  -> Strategy {cons("RealCong")}
    Char 			 	  -> Strategy {cons("CharCong")}

    String "(" {Strategy ","}* ")" 	  -> Strategy {cons("CongQ")}

    %%"(" {Strategy ","}* ")" 		  -> Strategy {cons("TupleCong"),avoid}

    Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
    "{" Strategy "}"		  	  -> StrategyCurly {cons("StrategyCurly")}

    "("  ")" 		  		  -> Strategy {cons("EmptyTupleCong")}
   "(" Strategy  ")" 		          -> Strategy {bracket}
    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy {cons("TupleCong")}

%%    Mod 	  			  -> Strategy {cons("ModCongNoArgs")}
%%    Mod "(" {Strategy ","}* ")"	  	  -> Strategy {cons("ModCong")}
%%    Id "^" Id				  -> Mod {cons("Mod")}
    "[" {Strategy ","}* "]" 		  -> Strategy {cons("ListCongNoTail")}
    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy {cons("ListCong")}

%%    Strategy "#" "(" StrategyInj ")" 	  -> Strategy {cons("ExplodeCong")}
%%    Strategy "#" "(" Strategy ")" 	  -> Strategy {cons("ExplodeCong")}
    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}

  %% Syntactic sugar sugar

  sorts SwitchCase
  context-free syntax

    SVar  		  		  -> Strategy {cons("CallNoArgs")}
    "\\" Rule "\\" 			  -> Strategy {cons("LRule")}
    "(" Rule ")" 			  -> Strategy {cons("SRule")}
    Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
    Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}

    "if" Strategy "then" Strategy 
                  "else" Strategy "end"   -> Strategy {cons("CondChoice")}
    "if" Strategy "then" Strategy "end"   -> Strategy {cons("IfThen")}

    "switch" Strategy SwitchCase* "end"   -> Strategy {cons("SwitchChoiceNoOtherwise")}
    "switch" Strategy SwitchCase*
         "otherwise" ":" Strategy "end"   -> Strategy {cons("SwitchChoice")}

    "case" Strategy ":" Strategy          -> SwitchCase {cons("SwitchCase")}

    Strategy "=>" Term 		  	  -> Strategy {cons("AM")}

    Term ":=" Term			  -> Strategy {cons("Assign")}

  %% Priorities

  context-free priorities
    { Strategy StrategyCurly		  -> Strategy
      Strategy "#" StrategyParen          -> Strategy
    }
  > { "!" Term 				  -> Strategy
      "?" Term 				  -> Strategy
    }
  > StrategyAngle Term 		          -> Strategy
  > Strategy "=>" Term 		  	  -> Strategy
  > Strategy ";" Strategy 		  -> Strategy
  > {right: 
     Strategy "+" Strategy 		  -> Strategy
     Strategy "<+" Strategy 		  -> Strategy
     Strategy "+>" Strategy 		  -> Strategy
     
     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy
    }

  context-free priorities
    Strategy 				  -> StrategyMid
  > Strategy "+" Strategy 		  -> Strategy

  context-free priorities
    { Strategy StrategyCurly      -> Strategy
      Strategy "#" StrategyParen  -> Strategy
    }
    .> Term ":=" Term -> Strategy




module Stratego-Sugar-Terms
imports
  Stratego-Core-Terms
  Stratego-Sugar-Strategies

exports
  sorts LID
  context-free syntax
    LId 			-> LID  {cons("ListVar")}
    LID				-> Var  {cons("Var")}
    LID				-> ID

  context-free syntax
    "_" PreTerm 		 -> PreTerm {cons("BuildDefaultPT")}
    "_" Term 			 -> Term {cons("BuildDefault"),prefer}

    Char 			 -> PreTerm {cons("Char")}

    PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
    PreTerm                      -> Term {cons("NoAnnoList")}

    "<" Strategy ">" Term 	 -> PreTerm {cons("App")}
    "<" Strategy ">" Term 	 -> Term {cons("App"),prefer}

    StrategyAngle		 -> PreTerm {cons("RootApp")}
    StrategyAngle		 -> Term {cons("RootApp"),prefer}

    "(" {Term ","}* ")" 	 -> PreTerm {cons("Tuple")}
    "[" {Term ","}* "]" 	 -> PreTerm {cons("List")}
    "[" {Term ","}* "|" Term "]" -> PreTerm {cons("ListTail")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
  > PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
  > Var "@" Term 		 -> Term {cons("As")}

module Stratego-Sugar-Signatures
imports
  Stratego-Core-Signatures
  Stratego-Sugar-Constants

exports

  sorts Sort
  context-free syntax
    "[" {Sort ","}* "]"		 -> Sort {cons("SortList")}
    "[" {Sort ","}* "|" Sort "]" -> Sort {cons("SortListTl")}
    "(" {Sort ","}* ")"		 -> Sort {cons("SortTuple")}

  sorts Kind
  context-free syntax
    "*" 			-> Kind {cons("Star")}
    "**" 			-> Kind {cons("StarStar")}

module Stratego-Core-Signatures
imports
  Stratego-Core-Identifiers
  Stratego-Core-Constants
exports
  sorts Sdecl
  context-free syntax
    "sorts" Sort* 		-> Sdecl {cons("Sorts")}
    "constructors" Opdecl* 	-> Sdecl {cons("Constructors")}

  sorts Sort
  context-free syntax
    LCID 			 -> Sort {cons("SortVar")}
    UCID 			 -> Sort {cons("SortNoArgs")}
    Id "(" {Sort ","}* ")" 	 -> Sort {cons("Sort")}

  sorts Opdecl
  context-free syntax
    Id     ":" Type 		-> Opdecl {cons("OpDecl")}
    String ":" Type 		-> Opdecl {cons("OpDeclQ")}
           ":" Type 		-> Opdecl {cons("OpDeclInj")}

  context-free syntax
    "external" Id     ":" Type 	-> Opdecl {cons("ExtOpDecl")}
    "external" String ":" Type 	-> Opdecl {cons("ExtOpDeclQ")}
    "external"        ":" Type 	-> Opdecl {cons("ExtOpDeclInj")}

  sorts Type ArgType ConstType FunType RetType
  context-free syntax
    Sort	                -> ConstType {cons("ConstType")}
    {ArgType "*"}+ "->" RetType -> FunType {cons("FunType")}
    "(" Type ")"                -> ArgType {bracket}
    ConstType			-> ArgType
    Type	                -> RetType
    FunType			-> RetType {reject}

    FunType			-> Type
    ConstType			-> Type

  %%%
   %% Restriction is required for the Sort* in Sdecl: List(a) is
   %% ambiguous.
   %%%
  context-free restrictions
    Sort -/- [\(]

module Stratego-Core-Terms
imports
  Stratego-Core-Identifiers
  Stratego-Core-Constants

exports
  sorts ID Var Wld
  context-free syntax
    Id 				-> Var  {cons("Var")}
    Id				-> ID
    %% ":" Var                  -> Var  {cons("SeqVar")}

  sorts Term PreTerm
  context-free syntax
    Var 			 -> PreTerm 
    Var 			 -> Term {prefer}

    "_" 			 -> Wld {cons("Wld")}
    Wld 			 -> PreTerm
    Wld 			 -> Term {prefer}

    Int 			 -> PreTerm {cons("Int")}
    Real 			 -> PreTerm {cons("Real")}
    String 			 -> PreTerm {cons("Str")}

    Id "(" {Term ","}* ")" 	 -> PreTerm {cons("Op")}
    String "(" {Term ","}* ")" 	 -> PreTerm {cons("OpQ")}
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}

    PreTerm "{^" PreTerm "}"	 -> Term {cons("Anno")}

    Var "@" Term 		 -> Term {cons("As"),prefer}
    Var "@" PreTerm 		 -> PreTerm {cons("As")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
  > Var "@" Term 		 -> Term {cons("As")}

module Stratego-Core-Strategies
imports
  Stratego-Core-Terms
  Stratego-Core-Constants
  Stratego-Core-Signatures

exports
  sorts Def
  context-free syntax
    StrategyDef					 -> Def 
    Id						 -> SVar {cons("SVar")}
    "let" Def* "in" Strategy "end"		 -> Strategy {cons("Let")}
    SVar "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallT")}

    "call" "(" Term "|" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallDynamic")}


  sorts StrategyDef
  context-free syntax
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDefT")}

    "external"
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("ExtSDefInl")}

    "external"
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}


  sorts Typedid
  context-free syntax
    ID ":" Type 			  -> Typedid {cons("VarDec")}


  sorts Strategy SVar StrategyParen StrategyMid 
  context-free syntax
    "(" Strategy ")"			  -> StrategyParen {cons("ParenStrat")}

    "fail" 				  -> Strategy {cons("Fail")}
    "id" 				  -> Strategy {cons("Id")}

    %% Match and build

    "?" Term 				  -> Strategy {cons("Match")}
    "!" Term 				  -> Strategy {cons("Build")}
    "{" {ID ","}* ":" Strategy "}" 	  -> Strategy {cons("Scope")}

    %% Combinators

    Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
    Strategy "<" StrategyMid 
             "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    Strategy 				  -> StrategyMid

    %% Primitives

    "prim" "(" String "," {Strategy ","}* "|" {Term ","}*")"  -> Strategy {cons("PrimT")}

    %% Traversal

    "some" "(" Strategy ")" 		  -> Strategy {cons("Some")}
    "one" "(" Strategy ")" 		  -> Strategy {cons("One")}
    "all" "(" Strategy ")" 		  -> Strategy {cons("All")}

  %% Priorities

  context-free priorities
    { "!" Term 				  -> Strategy {cons("Build")}
      "?" Term 				  -> Strategy {cons("Match")}
    }
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
  > {right: 
     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    }

  context-free syntax
    "import-term" "(" ModName ")" -> Strategy {cons("ImportTerm")}

module Stratego-Core-Modules
imports
  Stratego-Core-Identifiers
  Stratego-Core-Strategies
  Stratego-Core-Signatures

exports 
  sorts Module
  context-free syntax
    "module" ModName Decl* 	 -> Module {cons("Module")}
    "specification" Decl*	 -> Module {cons("Specification")}

  sorts Decl 
  context-free syntax
    "imports" ImportModName* 	-> Decl {cons("Imports")}
    "strategies" Def* 		-> Decl {cons("Strategies")}
    "signature" Sdecl*  	-> Decl {cons("Signature")}

  sorts ImportModName
  context-free syntax
    ModName              -> ImportModName {cons("Import")}
  syntax
    <ModName-CF> "/" "-" -> <ImportModName-CF> {cons("ImportWildcard")}

module Stratego-Sugar-Modules
imports
  Stratego-Core-Modules
  Stratego-Sugar-Strategies
  Stratego-Sugar-Signatures
  Stratego-Sugar-Overlays
  Stratego-Sugar-Rules

exports 

  sorts Decl Def
  context-free syntax
    "rules" Def* 		-> Decl {cons("Rules")}
    "overlays" Overlay* 	-> Decl {cons("Overlays")}

    RuleDef 			-> Def 




module Stratego-Core-Constants
exports
  sorts Int Real String StrChar
  lexical syntax
    [\-]? [0-9]+ 		-> Int
    [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
    "\"" StrChar* "\"" 		-> String
    ~[\"\\] 			-> StrChar
    [\\] [\"tnr\\] 		-> StrChar




module Stratego-Sugar-Constants
imports Stratego-Core-Identifiers Stratego-Core-Constants
exports
  sorts Char CharChar
  lexical syntax
    "'" CharChar "'"		-> Char
    ~[\']			-> CharChar
    [\\] [\'ntr\ ]		-> CharChar
    Char		 	-> Id {reject}

module Stratego-Core-Identifiers
exports
  sorts ModName ModNamePart
  lexical syntax
    {ModNamePart "/"}+ -> ModName
    [a-zA-Z\.\_] [a-zA-Z0-9\'\.\-\_]* -> ModNamePart
  lexical restrictions
    ModName -/- [a-zA-Z0-9\'\.\-\_]
  lexical syntax
    "imports" 		-> ModName {reject}
    "overlays" 		-> ModName {reject}
    "rules" 		-> ModName {reject}
    "signature" 	-> ModName {reject}
    "strategies" 	-> ModName {reject}

  sorts Id LId LCID UCID Wld
  lexical syntax
    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]*     -> Id
    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]* "*" -> LId
    [\'] [a-z]+                       -> Id

    [a-z] [a-zA-Z0-9\'\-\_]*  -> LCID
    [A-Z] [a-zA-Z0-9\'\-\_]*  -> UCID

  lexical restrictions
    Id   -/- [a-zA-Z0-9\'\-\_\*]
    LId  -/- [a-zA-Z0-9\'\-\_]
    LCID -/- [a-zA-Z0-9\'\-\_]
    UCID -/- [a-zA-Z0-9\'\-\_]

  lexical syntax
    "_"     -> Id {reject}
    "'"     -> Id {reject}

    Keyword -> Id   {reject}
    Keyword -> LId  {reject}
    Keyword -> LCID {reject}
    Keyword -> UCID {reject}

  lexical restrictions
    "all"
    "case" %% not reserved kw
    "constructors"
    "else" %% not reserved kw
    "end" %% not reserved kw
    "external" %% not reserved kw
    "fail"
    "id"
    "if" %% not reserved kw
    "in"
    "imports" %% not reserved kw
    "let"
    "module"
    "not"
    "one"
    "overlays"
    "otherwise" %% not reserved kw
    "prim"
    "rec" %% not reserved kw
    "rules"
    "script"
    "signature"
    "some"
    "sorts"
    "strategies"
    "stratego"
    "switch" %% not reserved kw
    "test"
    "then" %% not reserved kw
    "where"
    "import-term"
      -/- [a-zA-Z0-9\'\-\_]
  
  context-free restrictions
    Wld -/- [a-zA-Z0-9\'\-\_]

  sorts Keyword
  lexical syntax
    "all"               -> Keyword
    "constructors" 	-> Keyword
    "fail" 		-> Keyword
    "id" 		-> Keyword
    "in" 		-> Keyword
    "let" 		-> Keyword
    "module" 		-> Keyword
    "not" 		-> Keyword
    "one" 		-> Keyword
    "overlays" 		-> Keyword
    "prim" 		-> Keyword
    "rules" 		-> Keyword
    "script" 		-> Keyword
    "signature" 	-> Keyword
    "some" 		-> Keyword
    "sorts" 		-> Keyword
    "strategies" 	-> Keyword
    "stratego" 		-> Keyword
    "test" 		-> Keyword
    "where" 		-> Keyword
    "import-term"	-> Keyword




module Stratego-Core-Layout
exports
  sorts Ws ShortCom LongCom CommChar Asterisk Eof 
  lexical syntax
    [\t\ \n\r]			-> Ws

    "//" ~[\n]* ([\n] | Eof)	-> ShortCom
    "/*" CommChar* "*/"	-> LongCom
				-> Eof  

    ~[\*]     -> CommChar

    "*"       -> Asterisk
    Asterisk  -> CommChar

  lexical restrictions
    Asterisk -/- [\/]
    Eof      -/- ~[]

  lexical syntax
    ShortCom 	-> LAYOUT
    LongCom 	-> LAYOUT
    Ws 		-> LAYOUT

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/].[\*]
    LAYOUT? -/- [\/].[\/]

module Stratego-Sugar-Layout
imports Stratego-Core-Layout
%%exports
%%  sorts VeryLongCom Eof VLCchar Backslash
%%  lexical syntax
%%    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
%%    "\\begin{code}" 			   -> VeryLongCom
%%    "\\end{code}" VLCchar* Eof 		   -> VeryLongCom
%%    "\\literate" VLCchar* "\\begin{code}"  -> VeryLongCom
%%    ~[\\] 				   -> VLCchar
%%    Backslash 				   -> VLCchar
%%    [\\] 				   -> Backslash

%%  lexical restrictions
%%    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
%%    Eof -/- ~[]

%%  lexical syntax
%%    VeryLongCom -> LAYOUT





module Stratego-Sugar
imports
  Stratego-Sugar-Layout
  Stratego-Core-Identifiers
  Stratego-Sugar-Constants 
  Stratego-Sugar-Modules
  Stratego-Sugar-Signatures
  Stratego-Sugar-Terms
  Stratego-Sugar-Strategies
  Stratego-Sugar-Rules
  Stratego-Sugar-DynamicRules
  Stratego-Sugar-Overlays

hiddens
  context-free start-symbols Module

module Stratego
imports Stratego-Sugar
hiddens
  context-free start-symbols Module

module StrategoMix[Ctx0]
imports Stratego
          [ RuleNames      => RuleNames[[Ctx0]]
            RuleDec        => RuleDec[[Ctx0]]
            DynRuleScopeId => DynRuleScopeId[[Ctx0]]
            DynRuleId      => DynRuleId[[Ctx0]]
            DynRuleDef     => DynRuleDef[[Ctx0]]
            ScopeLabels    => ScopeLabels[[Ctx0]]
            RuleCond       => RuleCond[[Ctx0]]
            Rule           => Rule[[Ctx0]]
            RuleDef        => RuleDef[[Ctx0]]
            Overlay        => Overlay[[Ctx0]]
            SwitchCase     => SwitchCase[[Ctx0]]
            StrategyCurly  => StrategyCurly[[Ctx0]]
            StrategyAngle  => StrategyAngle[[Ctx0]]
            Kind           => Kind[[Ctx0]]
            LID            => LID[[Ctx0]]
            ImportModName  => ImportModName[[Ctx0]]
            Decl           => Decl[[Ctx0]]
            Module         => Module[[Ctx0]]
            StrategyParen  => StrategyParen[[Ctx0]]
            Typedid        => Typedid[[Ctx0]]
            StrategyDef    => StrategyDef[[Ctx0]]
            SVar           => SVar[[Ctx0]]
            Def            => Def[[Ctx0]]
            Type           => Type[[Ctx0]]
            RetType        => RetType[[Ctx0]]
            ArgType        => ArgType[[Ctx0]]
            FunType        => FunType[[Ctx0]]
            ConstType      => ConstType[[Ctx0]]
            Opdecl         => Opdecl[[Ctx0]]
            Sort           => Sort[[Ctx0]]
            Sdecl          => Sdecl[[Ctx0]]
            Wld            => Wld[[Ctx0]]
            ID             => ID[[Ctx0]]
            Var            => Var[[Ctx0]]
            CharChar       => CharChar[[Ctx0]]
            Char           => Char[[Ctx0]]
            StrChar        => StrChar[[Ctx0]]
            String         => String[[Ctx0]]
            Real           => Real[[Ctx0]]
            Int            => Int[[Ctx0]]
            Keyword        => Keyword[[Ctx0]]
            UCID           => UCID[[Ctx0]]
            LCID           => LCID[[Ctx0]]
            LId            => LId[[Ctx0]]
            Id             => Id[[Ctx0]]
            ModNamePart    => ModNamePart[[Ctx0]]
            ModName        => ModName[[Ctx0]]
            PreTerm        => PreTerm[[Ctx0]]
            Term           => Term[[Ctx0]]
            StrategyMid    => StrategyMid[[Ctx0]]
            Strategy       => Strategy[[Ctx0]] ]


module Stratego-Java-15
imports
  StrategoMix[StrategoHost]
  languages/java/EmbeddedJavaMix[JavaObject Term[[StrategoHost]]]

exports
  context-free start-symbols Module[[StrategoHost]]